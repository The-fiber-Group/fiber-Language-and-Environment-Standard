<!DOCTYPE html>
<head>
	<title>Report on ASC</title>
	<meta charset="UTF-8">
	<style>
		body{padding:3ch;padding-left:13ch;padding-right:13ch;background-color:rgb(241, 234, 221); color:rgb(41, 9, 33); font-size:large; font-family: serif;}
		p, dl, table{margin:0;margin-left:3ch;margin-right:3ch;padding-left:3ch;padding-right:3ch;margin-bottom:1ch;}
		h1{border-bottom:1px solid black;}
		dt{font-style:italic;}
		li, dd, dt{margin-left:7%; margin-right:7%; margin-bottom:1ch;}
		dt{font-weight:bold;}
		ul li{border:none;}
		table{border:1px solid black; border-spacing:3ch 1ch; margin-top: 3ch;}
		a{color:inherit;}
		a:hover{background-color: lightgrey;}
		code{background-color:lightgrey;}
		table table{border-style:none;}
		h3 {text-align:center;border-bottom:1px solid black; width:50%;margin-left:25%;margin-right:50%;}
		h4, h5, h6 {text-align:center;width:50%;margin-left:25%;margin-right:50%;}
		rec{font-size:smaller;color:#83817a;}
		#bottom{background-color:rgb(241, 234, 221);position:fixed;bottom:0;width:90%;text-align:center;}
		#bottom a{margin-right:3ch;}
		@media print {
			h1{page-break-before:always;}
			h1,h2,h3,h4,h5,h6,dt{page-break-after:avoid;}
			table,li,dd{page-break-inside:avoid;}
		}
	</style>
</head>
<body>
	<div id="bottom">
		<h2><a href="">Previous</a>
		<a href="toc.html">Table of Contents</a>
		<a href="toc.html">Next</a></h2>
	</div>

	<h1>Introduction</h1>
	<ol>
		<li><p>
			This report gives a definitive formal description of a programming language, the Algebra System for Computation, or ASC.
			ASC is an imperative programming language with a small, extensible base.
			It is unique in that it focuses on implementing a concept called "computer algebra".
		</p></li>
		<li><p>
			Computer algebra is an informal term coined specifically to represent the design goals of this programming language.
			Where algebra can generally be described as some objects paired with a set of operations to combine them, 
			computer algebra specifically regards what basic objects are necessary for general computation.
		</p></li>
		<li><p>
			In contrast to systems that generalize over mathematics, logic, or geometry, computer algebra generalizes over algorithms.
			This is different than systems such as the Turing Machine or Lambda Calculus because computer algebra is not reductive. 
			It does not require basic numerical or mathematical constructs to be "encoded" using lower-order abstract constructs such as function abstraction or infinite tape hardware.
		</p></li>
		<li><p>
			Languages that are extruded from mathematics or theory tend to stay rooted in arbitrary abstraction which can add unecessary non-determinism, non-computable constructs, and infinities.
			Languages that are extensions of some computer architecture are limited by the application domain of that architecture and are not fully expressive in terms of computable algorithms.
			Computer algebra avoids these pitfalls by focusing on defining static algorithms which are evaluated within a non-infinite environment.
			Algorithms and the information they modify are defined relative to the algorithms themselves, rather than reifying them in a theory or hardware implementation.
		</p></li>
		<li><p>
			Computer algebra is strictly constructive.
			This avoids any paradoxes that may be introduced by induction or logical negation.
			The information in the language environment is assumed to be strictly finite, there are no infinitely recursive or inductive structures.
			Information is available exactly when it is instantiated, rather than when it is used or needed.
		</p></li>
		<li><p>
			Computer algebra then exhibits the following traits...
		</p>
		<ul>
			<li>computation which is strictly applied and never deferred or inferred, that is to say, eager evaluation</li>
			<li>composite data types which support random access to their values</li>
			<li>all information including the algorithm itself is a first-class object which is accessible in the environment</li>
			<li>the placement of an object can be reified as another object, a reference or pointer</li>
			<li>functions which accept and return any number of parameters</li>
			<li>data duplication is strictly explicit, function parameters are passed by reference</li>
			<li>the available environment is assumed to have a finite and limited information capacity</li>
			<li>a data type system which can be arbitrarily extended with new type definitions</li>
			<li>notation which can reflectively expand itself with new syntax</li>
			<li>modularity such that portions of an algorithm or program can be separated into reuseable components</li>
		</ul</li>
	</ol>
	<h2 id="rationale">Rationale</h2>
	<ol>
		<li><p>
			Computer sciences and theory are comparatively new.
			Other practices have existed for hundreds of years while the general concept of an automatic computer is barely more than a century old (at the time of writing).
			Other fields which are more established and mature have their own formalized notation which is general across the entire field.
			Computation is one of the few which remains splintered. 
			It is a topic which has only been described by reifying its concepts according to some other field of mathematics or science such as boolean logic or modern algebra.
			A method must be defined through which computing concepts can be described in terms relative to computation.
		</p></li>
		<li><p>
			ASC is an attempt to formally define a language which is both definite and general across the entire field of computation.
			It combines the concepts of data, environment, abstraction, and mutation in a cohesive manner as an algebraic system which can be used for any application.
			In order to realize this, it is defined semantically, without relying on any existing theory or practice.
			This is not to say that ASC does not express such concepts as ordinality, type, binary arithmetic, or grouping, but only that these concepts are constructed using ASC itself rather than drawing from other systems.
		</p></li>
		<li><p>
			The intent of ASC is that it may be used universally as a system for both abstract problem-solving and computer programming.
			It exists as an independent tool which does not rely on any theory or physical mechanism to function other than the human subject.
			Thus it may be used regardless of any form that computation may take in the future.
		</p></li>
	</ol>
</body>