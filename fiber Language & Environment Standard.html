<!DOCTYPE html>
<head>
	<title>The fiber Language and Environment Standard</title>
	<style>
		body{padding:3ch; background-color:#fffdf6; color:#2a0d35; font-size:large; font-family: serif;}
		p, dl, table
		{
			margin:0;
			margin-left:3ch;
			margin-right:3ch;
			padding-left:3ch;
			padding-right:3ch;
		}
		h1{border-bottom:1px solid black;}
		dt{font-style:italic;}
		li, dd, dt{margin-left:7%; margin-right:7%; margin-bottom:1ch;}
		dt{font-weight:bold;}
		/*ol li{border-top:1px solid black;}*/
		ul li{border:none;}
		code{background-color:lightgrey;}
		table{border:1px solid black; border-spacing:3ch 1ch; margin-top: 3ch;}
		a{color:inherit;}
		a:hover{background-color: lightgrey;}
		table table{border-style:none;}
		h3 {text-align:center;border-bottom:1px solid black; width:50%;margin-left:25%;margin-right:50%;}
		h4, h5, h6 {text-align:center;width:50%;margin-left:25%;margin-right:50%;}
		rec{font-size:smaller;color:#83817a;}
		@media print {
			h1{page-break-before:always;}
			h1,h2,h3,h4,h5,h6,dt{page-break-after:avoid;}
			table,li,dd{page-break-inside:avoid;}
		}
	</style>
</head>
<body>
	<h1 style="page-break-before:avoid">The fiber Language and Environment Standard</h1>
	<h2>Revision 0.0</h2>
	<h1>Contents</h1>
	<ul>
		<li><a href="#foreword">Foreword</a></li>
		<li><a href="#introduction">Introduction</a></li>
		<li><a href="#scope">Scope</a></li>
		<li><a href="#terms">Terms</a></li>
		<li><a href="#conformance">Conformance</a></li>
		<li><a href="#environment">Environment</a></li>
		<li><a href="#isa">Architecture</a></li>
		<li><a href="#instructions">Instructions</a></li>
		<li><a href="#object">Binary Object Format</a></li>
		<li><a href="#execution">Execution</a></li>
	</ul>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1 id="foreword">Foreword</h1>
	<ol>
		<li>
			<p>
				The fiber Language and Environment Specification is considered an "open standard", meaning that...
			</p>
			<ul>
				<li>This document shall be made freely available, within reason, at all times, so long as availability incurs no cost to the owner of a copy of this document.</li>
				<li>There will be as little restriction as possible to reproducing this document in whole.</li>
				<li>The concepts and workings described in this document may be used freely, without royalties, licensing fees, or other payment owed from the user.</li>
				<li>Individuals or groups contributing to this document agree that they relinquish individual ownership of any work which becomes incorporated into this document.</li>
			</ul>
		</li>
	</ol>
	<h2>Authoring</h2>
	<ol>
		<li><p>
			The "fiber Group" is the designated central body of authors that shall and maintain this Standard and its documentation.
			Any individual who's work is incorporated into this Standard shall be included in the fiber Group.
		</p></li>
		<li><p>
			All rights concerning this Standard, its documentation, and the concepts described therein are reserved by the fiber Group as a collective whole.
		</p></li>
		<li><p>
			The fiber Group is responsible for the development of this Standard and any concepts it describes.
		</p></li>
		<li><p>
			The fiber Group shall include a "central" authorship role for a single author that grants them the exclusive right to overrule any and all decisions made by the fiber Group.
			The central author shall not have the ability to proactively make independent decisions for the fiber Group.
			This position shall be passed to another author at the central author's discretion.
			If the previous central author is not available to appoint a new central author, the new central author shall be chosen from the fiber Group by a majority vote of the fiber Group members.
		</p></li>
		<li id="authoring changes">
			<p>
				Changes or additions to this Standard may be proposed from outside the fiber Group.
				These changes should be communicated in a well documented proposal.
			</p>
			<p>
				A proposal must...
			</p>
			<ul>
				<li>clearly describe what changes it is proposing</li>
				<li>note what portions of this Standard the proposal would affect if it were accepted</li>
				<li>provide a rationale for the changes or additions</li>
				<li>give a detailed description of all properties of the changes or additions</li>
				<li>note the ramifications of each change or addition to this Standard</li>
			</ul>
		</li>
		<li><p>
			This Standard will be formatted and distributed as an HTML document.
			HTML is compact, efficient to maintain, an can be navigated quickly.
			Web browsers and other HTML document renderers are ubiquitous across all user-oriented devices.
			Almost all operating systems are distributed with a default web browser.
			Additionally, the HTML language does not rely on the support and maintenance of any one single party and therefore the format has wider adaptability and a longer support lifetime.
			This ensures that the documentation for this Standard will be optimally accessible for a very long period of time.
		</p></li>
	</ol>
	<h2>Document Organization</h2>
	<ol>
		<li><p>
			This document is divided into a hierarchy of labelled sections that contain numbered clauses.
		</p></li>
		<li><p>
			Each section may have any number of labelled subsections.
		</p></li>
		<li><p>
			Sections will not be numbered, only clauses.
		</p></li>
		<li><p>
			Clauses shall contain a few sentences regarding a single topic or idea.
		</p></li>
	</ol>
	<h2>Versioning</h2>
	<ol>
		<li><p>
			There shall only ever be one approved version of this Standard at a time.
			Previous versions of this standard are not considered valid.
		</p></li>
		<li><p>
			Versions of this document are called <u>Revisions</u>.
		</p></li>
		<li><p>
			The version number shall be represented by a pair of two-digit numbers separated by a decimal dot.
			The numbers begin at zero and are increased with every modification to the document.
		</p></li>
		<li><p>
			The first number is increased with large modifications.
			The second number is increased with small modifications.
		</p></li>
		<li><p>
			With each iteration of the first number, the second number is reset to "00".
		</p></li>
		<li><p>
			The addition or deletion of an entire section or secondary sub-section is considered a large modification.
			A large modification also occurs when the second version number has reached "99" and another small modification occurs.
		</p></li>
		<li><p>
			The addition or deletion of a tertiary or lower sub-section is considered a small modification.
			The modifiation of the contents of a section is also considered a small modification.
		</p></li>
		<li><p>
			New versions shall be released when a substantial amount of modifications have occurred.
			The amount of modification considered substantial is left to the author(s) discretion.
		</p></li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1 id="introduction">Introduction</h1>
	<ol>
		<li><p>
			This Standard describes a programming language and a runtime designed for execution programs written in that language.
		</p></li>
		<li><p>
			All properties of the standard described in this document are permanent and cannot be arbitrarily removed.
		</p></li>
		<li><p>
			Other properties may be added later only if they do not affect currently existing properties.
		</p></li>
		<li><p>
			If two properties are found to conflict, the most recently added, or least significant, property should be removed.
		</p></li>
		<li><p>
			Existing properties may be changed if the general design of computing technology has developed to a point where its functionality is so foreign to the architectures targeted by this standard that the language is no longer compatable or viable on that architecture.
			The commonality of the incompatable architecture must be taken into account for this clause to apply.
			If the architecture in question is not generally used in most computing applications, this standard is not required to be adapted to suit that architecture.
		</p></li>
	</ol>
	<h2>Notation Conventions</h2>
	<ol>
		<li><p>
			Examples are provided to show a selection fo possible forms a construct can take in actual use.
			Examples will be given in a <code>monospaced font.</code>
		</p></li>
		<li><p id="Reference">
			References are used in this document to refer to material in other sections.
			References are given by the section title and clause number in italics in parentheses <a href="#Reference">(<i>Notation Conventions, 2</i>)</a>.
		</p></li>
		<li><p>
			Terms defined within this document will be cited using a numbered, hypertext link <sup><a href="#terms">0</a></sup>.
			All appearances of terms are not required to be cited, but the first appearance of a term should be cited.
		</p></li>
		<li><p>
			Recommendations are provided to suggest helpful approaches for implementors.
			Recommendations are not requirements.
			<rec>Recommendations are written with a slightly smaller, and lighter colored font.</rec>
		</p></li>
		<li><p>
			Without sacrificing clarity, preference should always be given to plain language, rather than technical language, when describing ideas in this Standard.
		</p></li>
	</ol>
	<h2>Grammar Notation</h2>
	<ol>
		<li><p>
			Syntax structure is organized into terminal and non-terminal entities using simple Bakus-Naur forms.
		</p></li>
		<li><p>
			The names of non-terminal entities are written in <b>bold font</b>, followed by an arrow (&rarr;).
		</p></li>
		<li><p>
			Each non-terminal is followed by a series of other terminal or non-terminal entities separated by vertical bars.
		</p></li>
		<li><p>
			The names of terminal entities are writetn in <i>italicized font</i> followed by an arrow (&rArr;).
		</p></li>
		<li><p>
			Each terminal entity is followed by a single expressin of POSIX Extended Regular Syntax.
		</p></li>
		<li><p>
			An entity that is neither bold nor italicized refers to the top non-terminal entity from an external syntax diagram.
		</p></li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1 id="scope">Scope</h1>
	<ol>
		<li><p>
			This standard specifies the form and interpretation of computer programs written in the fiber language.
		</p></li>
		<li>
			<p>This Standard specifies...</p>
			<ul>
				<li>the representation of fiber programs</li>
				<li>the syntax of the fiber language</li>
				<li>the interpretation of fiber programs</li>
				<li>the representation fo data manipulated by fiber programs</li>
				<li>the restrictions and limits set to a "confoming implementation" of this standard</li>
				<li>the emulated computer architecture with which fiber programs may be executed with</li>
				<li>the instruction set that is interpreted by the emulated computer architecture</li>
				<li>the format for storing programs to be executed by the emulated computer architecture</li>
			</ul>
		</li>
		<li>
			<p>This standard does not specify...</p>
			<ul>
				<li>the methods by which a fiber program is transformed for use in the emulated computer architecture</li>
				<li>the methods by which a fiber program is executed by the emulated computer architecture</li>
				<li>the methods that may be used to invoke a fiber program</li>
				<li>the resolution of the capabilities of the emulated computer architecture with the underlying computer hardware</li>
				<li>the architecture-specific capacity limits that may affect a fiber program or the emulated computer architecture</li>
				<li>the methods by which output data is transformed after it leaves a fiber program</li>
				<li>the minimum requirements a computer architecture needs to support a conforming implementation of fiber.</li>
			</ul>
		</p></li>
	</ol>
	<h2>Purpose</h2>
	<ol>
		<li><p>
			The concepts described in this Standard can be roughly grouped into two catagories, the execution <u>environment</u>, and the <u>programming language</u> (as per the title of this Standard).
			The constructs and systems described in these two catagories are not dependent on each other.
		</p></li>
		<li><p>
			The execution environment can be used to execute any program that can be stored in a format interpretable by the environment.
		</p></li>
		<li><p>
			The programming language can be translated to any arbitrary format for interpretation by any environment.
		</p></li>
		<li><p>
			The fiber Programming Language and its Environment are designed to be optimally compatible with each other, without constraining applications beyond those specified in this Standard.
		</p></li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1 id="terms">Terms</h1>
	<dl>
		<dt>bit</dt>
		<dd>The smallest unit of binary information; a one or zero value.</dd>

		<dt>byte</dt>
		<dd>The smallest adressable space in memory; a binary value eight bits long.</dd>

		<dt>word</dt>
		<dd>The maximum number of bits that can be held in a processor register; the number of bits in the largets possible memory address.</dd>

		<dt>data</dt>
		<dd>Information that is encoded in a machine-readable manner; information encoded using binary values.</dd>

		<dt>datum</dt>
		<dd>A single, finite unit of information.</dd>
		
		<dt>computer, computing device, computing machine</dt>
		<dd>A device used to perform transformations on data.</dd>
		
		<dt>computer program</dt>
		<dd>A set of stored instructions that a computing device may interpret to perform data transformations according to the program.</dd>

		<dt>computer system</dt>
		<dd>A computing device that includes software to facilitate the execution of programs; the combination of an operating system and computing machine.</dd>

		<dt>execution</dt>
		<dd>The act of interpreting a program and performing transformations on data accordingly.</dd>

		<dt>architecture, computer architecture</dt>
		<dd>A specific configuration of a computing device with methods of program storage and interpretation that may not be shared by other architectures or computing machinery.</dd>

		<dt>computer memory, memory</dt>
		<dd>Volatile data storage space that is usually addressable and mostly contiguous which is used to dynamically store information during the execution of a computer program.</dd>
		
		<dt>word, memory-word</dt>
		<dd>The unit of address resolution that memory access operations are aligned to.</dd>

		<dt>memory alignment</dt>
		<dd>The process of storing data in memory with respect to boundaries determined by the memory-word size.</dd>

		<dt>memory-aligned data</dt>
		<dd>Memory-aligned data is data that has been stored in computer memory in locations that align with memory-word boundaries.</dd>

		<dt>padding</dt>
		<dd>Portions of memory that do not contain data, which occupies unused memory addresses adjacent to memory-aligned data.</dd>

		<dt>instruction set</dt>
		<dd>A set of values that are interpreted by a computer </dd>
		
		<dt>program stack</dt>
		<dd>A portion of memory organized according to a stack data structure where data is dynamically stored during execution of a program.</dd>

		<dt>subroutine</dt>
		<dd>A unit or module of a whole program that can be executed and performs a specific task.</dd>

		<dt>function</dt>
		<dd>A specialized kind of subroutine that performs transformations on an immediate set of data that is volatile and often not reachable outside the execution of that subroutine.</dd>

		<dt>host system, host architecture, target architecture</dt>
		<dd>The computer system where execution of a fiber program is expected to take place.</dd>

		<dt id="term: system call">system call</dt>
		<dd>An operation performed by the CPU which activates a subroutine. This subroutine is normally performed by an operating system kernel.</dd>
	</dl>
	<h2>ASCII</h2>
	<ol>
		<li>
			<p>
				ASCII is a standardized encoding for the English alphabet, decimal numbers, and various punctuation and symbols.
				Below is a table showing the encoding for ASCII characters.
			</p>
			<table>
				<tr><th>Binary</th><th>Decimal</th><th>Hexadecimal</th><th>Glyph/Name</th></tr>
				<tr><td>0000 0000</td><td>0</td><td>00</td><td>Null</td></tr>
				<tr><td>0000 0001</td><td>1</td><td>01</td><td>Start of Heading</td></tr>
				<tr><td>0000 0010</td><td>2</td><td>02</td><td>Start of Text</td></tr>
				<tr><td>0000 0011</td><td>3</td><td>03</td><td>End of Text</td></tr>
				<tr><td>0000 0100</td><td>4</td><td>04</td><td>End of Transmission</td></tr>
				<tr><td>0000 0101</td><td>5</td><td>05</td><td>Enquiry</td></tr>
				<tr><td>0000 0110</td><td>6</td><td>06</td><td>Acknowledgement</td></tr>
				<tr><td>0000 0111</td><td>7</td><td>07</td><td>Bell</td></tr>
				<tr><td>0000 1000</td><td>8</td><td>08</td><td>Backspace</td></tr>
				<tr><td>0000 1001</td><td>9</td><td>09</td><td>Horizontal Tab</td></tr>
				<tr><td>0000 1010</td><td>10</td><td>0a</td><td>Line Feed</td></tr>
				<tr><td>0000 1011</td><td>11</td><td>0b</td><td>Vertical Tab</td></tr>
				<tr><td>0000 1100</td><td>12</td><td>0c</td><td>Form Feed</td></tr>
				<tr><td>0000 1101</td><td>13</td><td>0d</td><td>Carriage Return</td></tr>
				<tr><td>0000 1110</td><td>14</td><td>0e</td><td>Shift Out</td></tr>
				<tr><td>0000 1111</td><td>15</td><td>0f</td><td>Shift In</td></tr>
				<tr><td>0001 0000</td><td>16</td><td>10</td><td>Data Link Escape</td></tr>
				<tr><td>0001 0001</td><td>17</td><td>11</td><td>Device Control 1</td></tr>
				<tr><td>0001 0010</td><td>18</td><td>12</td><td>Device Control 2</td></tr>
				<tr><td>0001 0011</td><td>19</td><td>13</td><td>Device Control 3</td></tr>
				<tr><td>0001 0100</td><td>20</td><td>14</td><td>Device Control 4</td></tr>
				<tr><td>0001 0101</td><td>21</td><td>15</td><td>Negative Acknowledgement</td></tr>
				<tr><td>0001 0110</td><td>22</td><td>16</td><td>Synchronous Idle</td></tr>
				<tr><td>0001 0111</td><td>23</td><td>17</td><td>End of Transmission Block</td></tr>
				<tr><td>0001 1000</td><td>24</td><td>18</td><td>Cancel</td></tr>
				<tr><td>0001 1001</td><td>25</td><td>19</td><td>End of Medium</td></tr>
				<tr><td>0001 1010</td><td>26</td><td>1a</td><td>Substitute</td></tr>
				<tr><td>0001 1011</td><td>27</td><td>1b</td><td>Escape</td></tr>
				<tr><td>0001 1100</td><td>28</td><td>1c</td><td>File Separator</td></tr>
				<tr><td>0001 1101</td><td>29</td><td>1d</td><td>Group Separator</td></tr>
				<tr><td>0001 1110</td><td>30</td><td>1e</td><td>Record Separator</td></tr>
				<tr><td>0001 1111</td><td>31</td><td>1f</td><td>Unit Separator</td></tr>
				<tr><td>0010 0000</td><td>32</td><td>20</td><td>Space</td></tr>
				<tr><td>00100001</td><td>33</td><td>21</td><td>!</td></tr>
				<tr><td>00100010</td><td>34</td><td>22</td><td>"</td></tr>
				<tr><td>00100011</td><td>35</td><td>23</td><td>#</td></tr>
				<tr><td>00100100</td><td>36</td><td>24</td><td>$</td></tr>
				<tr><td>00100101</td><td>37</td><td>25</td><td>%</td></tr>
				<tr><td>00100110</td><td>38</td><td>26</td><td>&</td></tr>
				<tr><td>00100111</td><td>39</td><td>27</td><td>'</td></tr>
				<tr><td>00101000</td><td>40</td><td>28</td><td>(</td></tr>
				<tr><td>00101001</td><td>41</td><td>29</td><td>)</td></tr>
				<tr><td>00101010</td><td>42</td><td>2a</td><td>*</td></tr>
				<tr><td>00101011</td><td>43</td><td>2b</td><td>+</td></tr>
				<tr><td>00101100</td><td>44</td><td>2c</td><td>,</td></tr>
				<tr><td>00101101</td><td>45</td><td>2d</td><td>-</td></tr>
				<tr><td>00101110</td><td>46</td><td>2e</td><td>.</td></tr>
				<tr><td>00101111</td><td>47</td><td>2f</td><td>/</td></tr>
				<tr><td>00110000</td><td>48</td><td>30</td><td>0</td></tr>
				<tr><td>00110001</td><td>49</td><td>31</td><td>1</td></tr>
				<tr><td>00110010</td><td>50</td><td>32</td><td>2</td></tr>
				<tr><td>00110011</td><td>51</td><td>33</td><td>3</td></tr>
				<tr><td>00110100</td><td>52</td><td>34</td><td>4</td></tr>
				<tr><td>00110101</td><td>53</td><td>35</td><td>5</td></tr>
				<tr><td>00110110</td><td>54</td><td>36</td><td>6</td></tr>
				<tr><td>00110111</td><td>55</td><td>37</td><td>7</td></tr>
				<tr><td>00111000</td><td>56</td><td>38</td><td>8</td></tr>
				<tr><td>00111001</td><td>57</td><td>39</td><td>9</td></tr>
				<tr><td>00111010</td><td>58</td><td>3a</td><td>:</td></tr>
				<tr><td>00111011</td><td>59</td><td>3b</td><td>;</td></tr>
				<tr><td>00111100</td><td>60</td><td>3c</td><td><</td></tr>
				<tr><td>00111101</td><td>61</td><td>3d</td><td>=</td></tr>
				<tr><td>00111110</td><td>62</td><td>3e</td><td>></td></tr>
				<tr><td>00111111</td><td>63</td><td>3f</td><td>?</td></tr>
				<tr><td>01000000</td><td>64</td><td>40</td><td>@</td></tr>
				<tr><td>01000001</td><td>65</td><td>41</td><td>A</td></tr>
				<tr><td>01000010</td><td>66</td><td>42</td><td>B</td></tr>
				<tr><td>01000011</td><td>67</td><td>43</td><td>C</td></tr>
				<tr><td>01000100</td><td>68</td><td>44</td><td>D</td></tr>
				<tr><td>01000101</td><td>69</td><td>45</td><td>E</td></tr>
				<tr><td>01000110</td><td>70</td><td>46</td><td>F</td></tr>
				<tr><td>01000111</td><td>71</td><td>47</td><td>G</td></tr>
				<tr><td>01001000</td><td>72</td><td>48</td><td>H</td></tr>
				<tr><td>01001001</td><td>73</td><td>49</td><td>I</td></tr>
				<tr><td>01001010</td><td>74</td><td>4a</td><td>J</td></tr>
				<tr><td>01001011</td><td>75</td><td>4b</td><td>K</td></tr>
				<tr><td>01001100</td><td>76</td><td>4c</td><td>L</td></tr>
				<tr><td>01001101</td><td>77</td><td>4d</td><td>M</td></tr>
				<tr><td>01001110</td><td>78</td><td>4e</td><td>N</td></tr>
				<tr><td>01001111</td><td>79</td><td>4f</td><td>O</td></tr>
				<tr><td>01010000</td><td>80</td><td>50</td><td>P</td></tr>
				<tr><td>01010001</td><td>81</td><td>51</td><td>Q</td></tr>
				<tr><td>01010010</td><td>82</td><td>52</td><td>R</td></tr>
				<tr><td>01010011</td><td>83</td><td>53</td><td>S</td></tr>
				<tr><td>01010100</td><td>84</td><td>54</td><td>T</td></tr>
				<tr><td>01010101</td><td>85</td><td>55</td><td>U</td></tr>
				<tr><td>01010110</td><td>86</td><td>56</td><td>V</td></tr>
				<tr><td>01010111</td><td>87</td><td>57</td><td>W</td></tr>
				<tr><td>01011000</td><td>88</td><td>58</td><td>X</td></tr>
				<tr><td>01011001</td><td>89</td><td>59</td><td>Y</td></tr>
				<tr><td>01011010</td><td>90</td><td>5a</td><td>Z</td></tr>
				<tr><td>01011011</td><td>91</td><td>5b</td><td>[</td></tr>
				<tr><td>01011100</td><td>92</td><td>5c</td><td>\</td></tr>
				<tr><td>01011101</td><td>93</td><td>5d</td><td>]</td></tr>
				<tr><td>01011110</td><td>94</td><td>5e</td><td>^</td></tr>
				<tr><td>01011111</td><td>95</td><td>5f</td><td>_</td></tr>
				<tr><td>01100000</td><td>96</td><td>60</td><td>`</td></tr>
				<tr><td>01100001</td><td>97</td><td>61</td><td>a</td></tr>
				<tr><td>01100010</td><td>98</td><td>62</td><td>b</td></tr>
				<tr><td>01100011</td><td>99</td><td>63</td><td>c</td></tr>
				<tr><td>01100100</td><td>100</td><td>64</td><td>d</td></tr>
				<tr><td>01100101</td><td>101</td><td>65</td><td>e</td></tr>
				<tr><td>01100110</td><td>102</td><td>66</td><td>f</td></tr>
				<tr><td>01100111</td><td>103</td><td>67</td><td>g</td></tr>
				<tr><td>01101000</td><td>104</td><td>68</td><td>h</td></tr>
				<tr><td>01101001</td><td>105</td><td>69</td><td>i</td></tr>
				<tr><td>01101010</td><td>106</td><td>6a</td><td>j</td></tr>
				<tr><td>01101011</td><td>107</td><td>6b</td><td>k</td></tr>
				<tr><td>01101100</td><td>108</td><td>6c</td><td>l</td></tr>
				<tr><td>01101101</td><td>109</td><td>6d</td><td>m</td></tr>
				<tr><td>01101110</td><td>110</td><td>6e</td><td>n</td></tr>
				<tr><td>01101111</td><td>111</td><td>6f</td><td>o</td></tr>
				<tr><td>01110000</td><td>112</td><td>70</td><td>p</td></tr>
				<tr><td>01110001</td><td>113</td><td>71</td><td>q</td></tr>
				<tr><td>01110010</td><td>114</td><td>72</td><td>r</td></tr>
				<tr><td>01110011</td><td>115</td><td>73</td><td>s</td></tr>
				<tr><td>01110100</td><td>116</td><td>74</td><td>t</td></tr>
				<tr><td>01110101</td><td>117</td><td>75</td><td>u</td></tr>
				<tr><td>01110110</td><td>118</td><td>76</td><td>v</td></tr>
				<tr><td>01110111</td><td>119</td><td>77</td><td>w</td></tr>
				<tr><td>01111000</td><td>120</td><td>78</td><td>x</td></tr>
				<tr><td>01111001</td><td>121</td><td>79</td><td>y</td></tr>
				<tr><td>01111010</td><td>122</td><td>7a</td><td>z</td></tr>
				<tr><td>01111011</td><td>123</td><td>7b</td><td>{</td></tr>
				<tr><td>01111100</td><td>124</td><td>7c</td><td>|</td></tr>
				<tr><td>01111101</td><td>125</td><td>7d</td><td>}</td></tr>
				<tr><td>01111110</td><td>126</td><td>7e</td><td>~</td></tr>
				<tr><td>0111 1111</td><td>127</td><td>7F</td><td>Delete</td></tr>
			</table>
		</li>
	</ol>
	<h2>Unicode</h2>
	<p>
		Unicode is a standardized encoding scheme designed by the Unicode Consortium.
		It encodes glyphs using a multi-byte value encoding scheme.
	</p>
	<p>
		Unicode includes the ASCII table as a subset of the characters it supports.
	</p>

<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1 id="conformance">Conformance</h1>
	<ol>
		<li><p>
			In this Standard, the words "must", "shall", and "will" will be interpreted as a strict requirement of an implementation or program.
			"must not", "shall not", and "will not" will be interpreted as a strict prohibition.
		</p></li>
		<li><p>
			If a requirement is not met, the behavior of an implementation or program shall be undefined.
			The terms "undefined" and "not specified" are used in contexts where the any behavior or property will be acceptable.
		</p></li>
		<li><p>
			A <b>strictly conforming implementation</b> shall realize only the properties and requirements set out in this document.
		</p></li>
		<li><p>
			A <b>conforming implementation</b> shall fully realize the properties and requirements set out in this Standard and is allowed to exhibit properties or behavior not defined in this document.
			A conforming implementation with any properties that are not within the scope of this Standard shall not allow these other properties to affect any requirements or behavior described in this Standard.
		</p></li>
		<li><p>
			A <b>partial implementation</b> shall fully realize either the transformation of the fiber language to instructions to be interpreted by the fiber environment or other execution environment.
			A <b>partial implementation</b> may also fully realize the fiber environment for executing fiber programs without implementing the fiber programming language.
		</p></li>
		<li><p>
			A <b>partial implementation</b> is not required to implement any of the standard libraries for the fiber language.
		</p></li>
	</ol>
	<h2>Conformance Statement</h2>
	<ol>
		<li><p>
			Implementations of the fiber Language and Environment Standard shall include a conformance statement.
		</p></li>
		<li><p>
			The conformance statement should be accessible to users of the implementation with reasonable ease.
			The means through which the statement is included and presented to the user in an implementation are not part of this standard.
		</p></li>
		<li><p>
			A <u>strictly conforming implementation</u> shall include the statement:<br> 
			"<i>This is a complete implementation of the fiber 0.0 Language and Environment.</i>"
		</p></li>
		<li><p>
			A <u>conforming implementation</u> shall include the statement:<br> 
			"<i>This is a complete implementation of the fiber 0.0 Language and Environment with extensions.</i>"
		</p></li>
		<li><p>
			A <u>partial implementation</u> shall include the statement:<br> 
			"<i>This is an incomplete implementation of the fiber 0.0 Language and Environment.</i>"
		</p></li>
		<li><p>
			An implementation that provides a complete fiber environment shall include the statement:<br>
			"<i>This is an implementation of the fiber 0.0 Environment.</i>"
		</p></li>
	</ol>
	<h1 style="color:red;"><b><i>The sections below this marker are not finalized and are subject to rapid change.</i></b></h1>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1 id="environment">Environment</h1>
	<ol>
		<li><p>
			The fiber Language is designed for a specific, abstract environment.
			This environment is hereon referred to as "bran". (This is a pun in reference to the name of the programming language because the food bran is said to have "lots of fiber".)
		</p></li>
		<li>
			<p>
			Bran includes...
			</p>
			<ul>
				<li>an emulated CPU architecture</li>
				<li>an instruction set for the emulated CPU</li>
				<li>a limited memory model scheme facilitating structured program execution</li>
				<li>a binary object file format used for storing and distributing programs</li>
				<li>a linking and loading system for executing programs stored as binary objects</li>
			</ul>
		</li>
		<li><p>
			Bran does not abstract interactions with operating systems.
			The abstract CPU architecture does not include many architecture specific behaviors.
			Functionality for, among other things, privilege levels, memory security, and ports are not considered.
			<rec>It is discouraged to extend an implementation with support for these functionalities.</rec>
		</p></li>
		<li><p>
			Bran allows for fiber program components to be stored in either a system-native or fiber environment-native format.
		</p></li>
		<li><p>
			Bran allows for fiber program components of any system-native or fiber environment-native format to be combined and executed as one cohesive program.
		</p></li>
		<li><p>
			Bran is designed to function transparently in the underlying system.
		</p></li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1 id="isa">Architecture</h1>
	<ol>
		<li><p>
			The instruction set for the Bran architecture is a RISC instruction set referred to as BRISC (Bran Reduced Instruction Set Computer).
		</p></li>
		<li><p>
			The purpose of BRISC is to provide a portable medium to store programs that will be translated to native instructions before execution on the host architecture.
			As such, BRISC involves some abstractions in order to account for discrepancies between architectures.
		</p></li>
		<li><p>
			BRISC is encoded using values from the ASCII table.
		</p></li>
		<li><p>
			Multiple entities in BRISC syntax are identified using the same naming syntax.
			It is possible for multiple entities to share the same name.
		</p></li>
	</ol>
	<h2>Memory Model</h2>
	<ol>
		<li><p>
			The Bran architecture does not enforce a specific memory model.
			The position and memory addressing strategy is dependent on the target architecture.
			Memory addresses are described using relative terms such as "near" or "far".
		</p></li>
		<li><p>
			Any values stored in a BRISC program that are used as memory addresses are not guaranteed to be compatable with the target architecture or produce predictable results.
		</p></li>
		<li><p>
			The direction in which BRISC instructions will iterate along memory when implementing a program stack or accessing ordered data is dependent on the logial direction of memory implemented by the host system uses.
		</p></li>
		<li><p>
			The values produced from modifying the values held in memory address data types are unspecified.
			The behavior of a BRISC program that modifies and then uses a memory address is unspecified.
		</p></li>
		<li><p>
			Memory-word boundaries for BRISC are not specified.
		</p></li>
	</ol>
	<h3>Program Stack</h3>
	<ol>
		<li><p>
			The Bran architecture shall implement an abstract stack data structure that can be used as a program stack.
		</p></li>
		<li><p>
			This program stack shall occupy a portion of computer memory.
		</p></li>
		<li><p>
			The Bran program stack will support push and pop operations on the stack using register-word oriented data types.
		</p></li>
		<li><p>
			The size of the Bran program stack is dependent on the target architecture's implementation or support of a stack data structure.
		</p></li>
		<li><p>
			The Bran program stack direction, whether the top moves towards higher or lower memory address values, shall be dependent on the target architecture's implementation or support of a stack data structure.
		</p></li>
	</ol>
	<h3>Storing Data in Memory</h3>
	<ol>
		<li><p>
			A data type stored in memory shall be oriented to a "base address", which will be the position in memory where the "beginning" or first byte occupied by the data type is located.
		</p></li>
		<li><p>
			A data type shall always occupy a number of bytes in memory equivalent to the size of that data type in bytes.
		</p></li>
		<li><p>
			The bytes in memory, occupied by a data type, shall form a contiguous region with one of the inside boundaries being the base address.
		</p></li>
		<li><p>
			The number of bytes included in the region of memory occupied by a data type shall be equivalent to the number of bytes in the size of the data type.
		</p></li>
		<li><p>
			The region occupied by a data type shall extend away from the base address in a single direction.
			The direction in which the region extends is dependent on the direction used by the host system.
		</p></li>
	</ol>
	<h2>Registers</h2>
	<ol>
		<li><p>
				BRISC uses an unlimited number of temporary general purpose registers.
				Each register can hold a maximum of 128 bits.
		</p></li>
		<li>
			<p>
				Temporary registers shall be identified using a series of alphanumeric and blank-space characters.
				Register identifiers are delimited by the ASCII Data Link Escape code (10).
			</p>
			<table>
				<tr><td><i>register</i> &rArr; [a-zA-Z0-9 ]+\x1f</td></tr>
			</table>
			<p>
				A register name that contains characters other than the set described above shall not be accepted.
			</p>
		</li>
		<li><p>
			In a BRISC instruction being carried out in a target system, the contents of the target system's registers that are involved in carrying out that instruction shall match the contents of the temporary registers used in the BRISC instruction.
		</p></li>
		<li><p>
			The correlation between the contents of the native system registers and the temporary registers not immediately involved in an operation are unspecified.
		</p></li>
		<li><p>
			In the case of the execution of an instruction that writes data to some bytes of a register, but does not write to all sixteen bytes, the contents of the bytes not written to are unspecified.
		</p></li>
	</ol>
	<h3>Special Purpose Registers</h3>
	<ol>
		<li>
			<p>
				BRISC includes a set of special purpose registers that are guaranteed to be accessible at all times. 
			</p>
			<table>
				<tr><th>Register Name</th><th>Register Purpose</th></tr>
				<tr><td>/s</td><td>Holds the address of the top of the program stack.</td></tr>
				<tr><td>/b</td><td>Holds the address of the base of program stack.</td></tr>
				<tr><td>/z</td><td>Holds a static value of zero at all times. It cannot be written to.</td></tr>
				<tr><td>/i</td><td>Holds the address of the current instruction.</td></tr>
			</table>
		</li>
		<li><p>
			Each register name shall begin with the ASCII forward slash character.
		</p></li>
		<li><p>
			Special purpose register names are still delimited with the ASCII Data Link Escape code.
		</p></li>
	</ol>

	<h2>Data Types</h2>
	<ol>
		<li><p>
			There are two different classes of data types included in BRISC, Word-oriented and Alignment-oriented.
			They are respectively called Word Types and Compound Types.
		</p></li>
		<li><p>
			Word-oriented data types are comprised of a single datum.
			They hold various sizes of binary-encoded, numerical values.
		</p></li>
		<li><p>
			Alignment-oriented data types are used to group other types together so that they may be accessed relatively from the grouping.
		</p></li>
		<li><p>
			The ordering of individual bytes within a word data type is not specified.
			<rec>
				It is not recommended to access data at arbitrary positions with data types that do not match the data type used when storing it,
				as the exact positioning of the individual bytes within the data type is not guaranteed to be the same across all target architectures.
				This can be disregarded if the data types being used are bytes.
			</rec>
		</p></li>
		<li id="Data Types Size"><p>
			The size of all data types in BRISC can be accessed as numerical constants by prefixing a data type Mnemonic or Symbol with the ASCII Device Control 1 code (11).
			This will be interpreted as a constant, whole numerical value equivalent to the number of bytes in the size of the data type specified after the ASCII code.
		</p></li>
	</ol>
	<h3>Word Types</h3>
	<ol>
		<li>
			<p>Word-oriented data types are...</p>
			<table>
				<tr><th>Type</th><th>Mnemonic</th><th>Size</th></tr>
				<tr><td>Signed Word</td><td>w</td><td>64 b</td></tr>
				<tr><td>Unsigned Word</td><td>W</td></tr>
				<tr><td>Large Floating Point</td><td>F</td></tr>
				<tr><td>Signed Half-Word</td><td>h</td><td>32 b</td></tr>
				<tr><td>Unsigned Half-Word</td><td>H</td></tr>
				<tr><td>Small Floating Point</td><td>f</td></tr>
				<tr><td>Signed Quarter-Word</td><td>q</td><td>16 b</td></tr>
				<tr><td>Unsigned Quarter-Word</td><td>Q</td></tr>
				<tr><td>Signed Byte</td><td>b</td><td>8 b</td></tr>
				<tr><td>Unsigned Byte</td><td>B</td></tr>
				<tr><td>Memory Address</td><td>@</td><td>unspecified</td></tr>
			</table>
		</li>
		<li><p>
			The Memory Address data type in BRISC is unspecified as the size of a memory address varies greatly between different target architectures.
		</p></li>
		<li><p>
			The Memory Address data type shall have a size in bytes equivalent to the byte-size of the memory address data type available in the target architecture.
		</p></li>
		<li><p>
			The Large Floating Point and Small Floating Point data types shall conform to the IEEE 754-2008 standard 64 bit and 32 bit binary floating point formats respectively.
		</p></li>
	</ol>
	<h3>Compound Data Types</h3>
	<ol>
		<li><p>
			There are three Compound Data Types, the Box, the Index, and the Shelf.
			They are used to facilitate data organization patterns that are persistent across all target architectures.
		</p></li>
		<li><p>
			Compound data types contain one or more data fields.
			Each field is an individual data type.
		</p></li>
		<li><p>
			Data fields can be either Word data types or other Compound data types.
		</p></li>
		<li><p>
			A Data field cannot be a compound type matching the type containing the field.
			That means a Box type cannot contain any Box fields, an Index type cannot contain any Index fields, and a Shelf type cannot contain any Shelf fields.
		</p></li>
		<li><p>
			A Shelf type cannot be used as a data field at all.
		</p></li>
		<li><p>
			The data fields for a given compound data type shall be implicitly indexed using whole numerical values.
			The first data field declared shall be given an index of one.
			All following data fields will be assigned incrementally increasing index values such that the third data field will have an index of three, and the tenth index will have an index of ten.
		</p></li>
		<li><p>
			Data fields shall be stored in memory according to the order of their declaration.
			The first, or leftmost field declared shall be stored closest to the base address of the compound data type.
			The last, or rightmost field declared shall be stored farthest from the base address of the compound type. 
			The exact spacing of the fields is dependent on the compound data type being stored.
		</p></li>
		<li><p>
			The size in bytes of a Compound Data Type is determined by the sum of the byte-sizes of all its data fields.
		</p></li>
		<li><p>
			The size of a Compound Data Type shall include any unused bytes located between two data fields within the same Compound Data Type.
		</p></li>
		<li><p>
			The size of a Compound Data Type shall include any bytes between the last data field and the next memory-word boundary only if the last data field in that Compound Data Type is declared to be memory-aligned.
		</p></li>
		<li><p>
			Compound data types shall be accessed by their individual fields.
		</p></li>
		<li><p>
			A data field access operation shall produce the base address of the data field.
		</p></li>
		<li><p>
			A data field access operation for a Box or Index type will require the base address of the individual Box or Index being accessed.
		</p></li>
		<li><p>
			A Shelf type does not require a base address for an access operation.
			Data field access operations for Shelf types will always use the value in the <code>//s</code> register as the base address.
		</p></li>
		<li>
			<p>Syntax for data access operations is...</p>
			<table>
				<tr><td><b>DataAccess</b> &rarr; <i>Prefix</i> <i>Symbol</i> <i>Number</i> | <i>Prefix</i> <i>Address</i> <i>Symbol</i> <i>Number</i></td></tr>
				<tr><td><i>Prefix</i> &rArr; \x1a</td></tr>
				<tr><td><i>Symbol</i> &rArr; [\x20-\x7e]\x00</td></tr>
				<tr><td><i>Number</i> &rArr; [0-9a-f][0-9a-f]{1,16}</td></tr>
			</table>
		</li>
		<li><p>
			Data access operations will be prefixed with the ASCII Substitute code (1a).
		</p></li>
		<li><p>
			Data access operations use a <a href="#Object Symbol">Symbol</a> to specify which declared compound data type is being accessed.
		</p></li>
		<li><p>
			The data field being accessed is specified by a variable-width hexadecimal number.
			The number specifies the index of the field being accessed.
		</p></li>
		<li><p>
			The first digit of the hexadecimal number shall specify the number of digits of the actual number.
			A value of zero represents only one digit in the hexadecimal number.
			Increasing values represent increasing numbers of digits.
			A hexadecimal number consisting of sixteen digits is signified by the first digit being <code>f</code>.
		</p></li>
		<li><p>
			The hexadecimal number shall not consist of more than sixteen digits.
		</p></li>
		<li>
			<p>
				The Address can be one of...
			</p>
			<ul>
				<li>an address value stored in a register</li>
				<li>a data field access operation resulting in an address value</li>
				<li>a Symbol associated with an address value</li>
			</ul>
			<p>
				The syntax for one of these three options shall be included in the place where an address is expected in a data field access operation.
			</p>
		</li>
		<li><p>
			Data field access operations shall be possible using arbitrary address values.
			Behavior is not defined if an arbitrary address value is not the base address of a compound data type.
		</p></li>
		<li><p>
			Behavior is not specified if a data access operation is performed on a compound data type that is not the same as the type provided for the access operation.
		</p></li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1 id="instructions">Instructions</h1>
	<ol>
		<li><p>
			BRISC instructions are designed to correspond as closely as possible to instructions featured in many hardware instruction set architectures. 
		</p></li>
		<li><p>
			A single BRISC instruction shall always be interpreted to the instruction on the target architecture that exactly matches its behavior.
		</p></li>
		<li><p>
			If a BRISC instruction cannot be interpreted to a single counterpart instruction on the target architecture, the smallest possible number of multiple target architecture instructions shall be used to emulate the effect of the BRISC instruction.
		</p></li>
	</ol>
	<h2>Instruction Encoding</h2>
	<ol>
		<li>
			<p>
				Instructions are encoded in the order of...
			</p>
			<ol>
				<li>Primary Operand</li>
				<li>Instruction Mnemonic</li>
				<li>Word Data Type Specifier</li>
				<li>Secondary Operand</li>
				<li>Tertiary Operand</li>
				<li>Further Instruction-dependent Operands...</li>
			</ol>
		</li>
		<li><p>
			Depending on the instruction, operands may be register names, compound type access instructions, or either.
		</p></li>
		<li><p>
			The primary operand will always be used in every instruction that requires at least one operand.
			Secondary, tertiary, and other registers will be used when further operands are required by the instruction.
		</p></li>
		<li><p>
			The instruction components used for each class of instruction are given below in the tables in each section.
			The types of operands allowed for each instruction are specified as well as which operands are read or written to.
		</p></li>
		<li><p>
			The instruction mnemonic will always be immediately followed by a word data type specifier.
		</p></li>
		<li><p>
			The number of bytes used when executing an instruction will be determined by the byte-size of the word data type specifier given.
			All reading and writing actions performed when carrying out an instruction shall use the same number of bytes, determined by the size of the word data type specifier.
		</p></li>
	</ol>
	<h3>Non-Register Operands</h3>
	<ol>
		<li><p>
			There are several types of operands that can be encoded in BRISC instructions aside from registers.
		</p></li>
		<li><p>
			Operands are prefixed with an ASCII code that signifies the type of operand used.
		</p></li>
		<li>
			<p>The operands that shall be accepted in BRISC instructions are...</p>
			<ul>
				<li>Compound Data Type access operations</li>
				<li>Numbers, as described in <a href="#Object Number">(<i>Numbers</i>)</a></li>
				<li>Symbols, as described in <a href="#Object Symbol">(<i>Symbols</i>)</a></li>
				<li>The size of a data type, as described in <a href="#Data Types Size">(<i>Data Types, 5</i>)</a></li>
			</ul>
		</li>
		<li><p>
			Compound Data Type access operations and Symbols produce address values.
			In the instruction notation below, an instruction that accepts an Address operand will accept a Compound Data Type access operation or a Symbol.
		</p></li>
		<li><p>
			Numbers produce numerical values.
			In the instruction notation below, an instruction that accepts a Number operand will accept a Number or a data type size.
		</p></li>
	</ol>
	<h2>Memory Access Instructions</h2>
	<ol>
		<li><p>
			Memory access instructions are used to modify the contents of volatile computer memory.
		</p></li>
		<li>
			<table>
				<tr><th>Instruction</th><th>Primary Operand</th><th>Mnemonic</th><th>Secondary Operand</th><th>Reads from:</th><th>Writes to:</th></tr>
				<tr><td>Load:</td><td>Register</td><td>L</td><td>Register/Address</td><td>Secondary Operand</td><td>Primary Operand</td></tr>
				<tr><td>Load Immediate:</td><td>Register</td><td>I</td><td>Number</td><td>Immediate Value</td><td>Primary Operand</td></tr>
				<tr><td>Store:</td><td>Register/Address</td><td>S</td><td>Register</td><td>Secondary Operand</td><td>Primary Operand</td></tr>
				<tr><td>Copy:</td><td>Register</td><td>C</td><td>Register</td><td>Secondary Register</td><td>Primary Register</td></tr>
				<tr><td>Push to the Stack:</td><td>Register</td><td>P</td><td>-</td><td>Primary Operand</td><td>Program Stack</td></tr>
				<tr><td>Pop from the Stack:</td><td>Register</td><td>p</td><td>-</td><td>Program Stack</td><td>Primary Register</td></tr>
			</table>
		</li>
	</ol>
	<h3>Load</h3>
	<ol>
		<li><p>
			The Load instruction will copy a number of bytes to the primary operand register starting at the address specified by the secondary operand.
		</p></li>
		<li><p>
			The number of bytes copied to the primary operand will be determined by the size of the data type given with the instruction.
		</p></li>
		<li><p>
			The secondary operand accepts an address value either stored in a register or derived from a compound data type access.
		</p></li>
	</ol>
	<h3>Load Immediate</h3>
	<ol>
		<li><p>
			The Load Immediate instruction will copy a number of bytes encoded in the instruction to the register specified by the primary operand.
		</p></li>
		<li><p>
			The secondary operand of the instrution will be an encoded number as specified in <a href="#Object Number">(<i>Numbers</i>)</a>.
		</p></li>
	</ol>
	<h3>Store</h3>
	<ol>
		<li><p>
			The Store instruction will copy a number of bytes from the register specified by the secondary operand to a series of bytes in memory 
			beginning at the address specified by the primary operand and advancing a number of bytes specified by the data type specifier.
		</p></li>
		<li><p>
			The register specified by the primary operand is expected to contain a memory address value.
			Program behavior is not specified if the value is not a memory address data type.
		</p></li>
	</ol>
	<h3>Copy</h3>
	<ol>
		<li><p>
			The Copy instruction reads a number of bytes from a register specified by the secondary operand and writes them to the register specified by the primary operand.
			The value of bytes in the primary operand that were not written to after the instruction is carried out is unspecified.
		</p></li>
	</ol>
	<h3>Push to the Stack</h3>
	<ol>
		<li><p>
			The Push instruction will adjust the value in the <code>//s</code> register according to the direction of the program stack implementation used by the target system.
			The adjustment will be a number of bytes determined by the byte-size of the data type specifier.
			This adjustment will increase the logical "top" position of the stack.
		</p></li>
		<li><p>
			The memory address contained in <code>//s</code> after the Push instruction is completed will be the first address following the last address occupied by the data type that was stored by the Push instruction.
		</p></li>
	</ol>
	<h3>Pop from the Stack</h3>
	<ol>
		<li><p>
			The Pop instruction will adjust the value in the <code>//s</code> register according to the direction of the program stack implementation used by the target system.
			The adjustment will be a number of bytes determined by the byte-size of the data type specifier.
			This adjustment will decrease the logical "top" position of the stack.
		</p></li>
		<li><p>
			The memory address contained in <code>//s</code> after the Pop instruction is completed will be the the base address of the data type being "popped", given that the last address occupied by that data type is the address directly preceding the address of the "top" of the stack.
		</p></li>
	</ol>
	<h2>Math and Logic Instructions</h2>
	<ol>
		<li>
			<table>
				<tr><th>Instruction</th><th>Primary Operand</th><th>Mnemonic</th><th>Secondary Operand</th><th>Reads from:</th><th>Writes to:</th></tr>
				<tr><td>Addition:</td><td>Register</td><td>+</td><td>Register</td><td>Both Operands</td><td>Primary Operand</td></tr>
				<tr><td>Subtraction:</td><td>Register</td><td>-</td><td>Register</td><td>Both Operands</td><td>Primary Operand</td></tr>
				<tr><td>Multiplication:</td><td>Register</td><td>*</td><td>Register</td><td>Both Operands</td><td>Primary Operand</td></tr>
				<tr><td>Division:</td><td>Register</td><td>/</td><td>Register</td><td>Both Operands</td><td>Primary Operand</td></tr>
				<tr><td>Modulus:</td><td>Register</td><td>%</td><td>Register</td><td>Both Operands</td><td>Primary Operand</td></tr>
				<tr><td>Binary AND:</td><td>Register</td><td>&</td><td>Register</td><td>Both Operands</td><td>Primary Operand</td></tr>
				<tr><td>Binary OR:</td><td>Register</td><td>|</td><td>Register</td><td>Both Operands</td><td>Primary Operand</td></tr>
				<tr><td>Binary XOR:</td><td>Register</td><td>^</td><td>Register</td><td>Both Operands</td><td>Primary Operand</td></tr>
				<tr><td>Binary NOT:</td><td>Register</td><td>!</td><td>-</td><td>Primary Operand</td><td>Primary Operand</td></tr>
				<tr><td>Negate:</td><td>Register</td><td>n</td><td>-</td><td>Primary Operand</td><td>Primary Operand</td></tr>
			</table>
		</li>
	</ol>
	<h3>Mathematical Instructions</h3>
	<ol>
		<li>
			<p>
				Mathematical instructions are...
			</p>
			<ul>
				<li>Addition</li>
				<li>Subtraction</li>
				<li>Multiplication</li>
				<li>Division</li>
				<li>Modulus</li>
				<li>Negate</li>
			</ul>
		</li>
		<li><p>
			These instructions will read the contents of the registers of both the primary and secondary operands.
			They will write the result of the mathematical operation to the primary operand.
		</p></li>
		<li><p>
			For non-commutative operations, subtraction, division, and modulus, the primary operand is treated as the dividend or minuend.
			The secondary operand is treated as the divisor or subtrahend of the operation.
		</p></li>
		<li><p>
			The Negate instruction shall reverse the most significant bit in the register specified by the Primary Operand.
		</p></li>
		<li><p>
			The Negate instruction does not accept a secondary operand.
		</p></li>
	</ol>
	<h3>Logical Instructions</h3>
	<ol>
		<li>
			<p>Logical instructions are...</p>
			<ul>
				<li>Binary AND</li>
				<li>Binary OR</li>
				<li>Binary XOR</li>
				<li>Binary NOT</li>
			</ul>
		</li>
		<li><p>
			These instructions will read the contents of the registers of both the primary and secondary operands.
			They will write the result of the logical operation to the primary operand.
		</p></li>
		<li><p>
			Specifically, the Binary NOT instruction only requires a primary operand.
			A secondary operand will not be accepted.
		</p></li>
	</ol>
	<h2>Branch Instructions:</h2>
	<ol>
		<li>
			<table>
				<tr><th>Instruction</th><th>Primary Operand</th><th>Mnemonic</th><th>Secondary Operand</th><th>Tertiary Operand</th></tr>
				<tr><td>Unconditional Jump</td><td>Register/Address</td><td>@</td><td>Register</td><td>Register</td></tr>
				<tr><td>Branch if Greater or Equal</td><td>Register/Address</td><td>g</td><td>Register</td><td>Register</td></tr>
				<tr><td>Branch if Greater</td><td>Register/Address</td><td>&gt;</td><td>Register</td><td>Register</td></tr>
				<tr><td>Branch if Less or Equal</td><td>Register/Address</td><td>l</td><td>Register</td><td>Register</td></tr>
				<tr><td>Branch if Less</td><td>Register/Address</td><td>&lt;</td><td>Register</td><td>Register</td></tr>
				<tr><td>Branch if Equal</td><td>Register/Address</td><td>=</td><td>Register</td><td>Register</td></tr>
				<tr><td>Branch if Not Equal</td><td>Register/Address</td><td>_</td><td>Register</td><td>Register</td></tr>
			</table>
		</li>
		<li><p>
			All branch instructions will set the value held in the instruction register, <code>//i</code> to the value obtained from the primary operand.
		</p></li>
		<li><p>
			All branch instructions will perform a value comparison of the secondary operand against the tertiary operand.
			The result of this comparison is discarded.
			If the result of the comparison is successful, the value of the instruction register shall be set to the value of the Tertiary Operand.
		</p></li>
		<li><p>
			A comparison is successful if the Primary Operand has a true relationship to the Seconary Operand.
		</p></li>
		<li><p>
			None of the contents of any of the operands will be modified during a branch instruction.
		</p></li>
		<li><p>
			Behavior is undefined if the data types of the Primary and Secondary Operands do not match the word data type specifier.
		</p></li>
	</ol>
	<h2>Bit Shift Instructions</h2>
	<ol>
		<li>
			<table>
				<tr><th>Instruction</th><th>Primary Operand</th><th>Mnemonic</th><th>Secondary Operand</th></tr>
				<tr><td>Logical Shift Left</td><td>Register</td><td>O</td><td>Byte</td></tr>
				<tr><td>Logial Shift Right</td><td>Register</td><td>o</td><td>Byte</td></tr>
				<tr><td>Arithmetic Shift Right</td><td>Register</td><td>A</td><td>Byte</td></tr>
				<tr><td>Rotate Bits Left</td><td>Register</td><td>R</td><td>Byte</td></tr>
				<tr><td>Rotate Bits Right</td><td>Register</td><td>r</td><td>Byte</td></tr>
			</table>
		</li>
		<li><p>
			The secondary operand for all shift and rotation instructions is a byte containing the number of bits the contents will be shifted or rotated by, as a binary value.
			A range of binary values between <code>0000 0000</code> and <code>0011 1111</code> shall be accepted as shift and rotation distances.
		</p></li>
		<li><p>
			Shifts and rotations to the left will move bits towards higher significant positions.
			Shifts and rotations to the right will move bits towards lower significant positions.
		</p></li>
		<li><p>
			Bits are shifted within a boundary of a number of bytes in size.
			The size of the boundary is determined by the word data type specifier for the instruction.
		</p></li>
		<li><p>
			After the completion of a shift or rotation instruction, the contents of bytes in the register that were not within the boundary for that instruction are not specified.
		</p></li>
		<li><p>
			Each bit within a boundary will be shifted in the same direction determined by the instruction and will be shifted the same number of bits as determined by the secondary operand of the instruction.
		</p></li>
	</ol>
	<h3>Logical Shift Instructions</h3>
	<ol>
		<li><p>
			The Logical Shift instructions will shift the contents of a number of bytes in the register specified by the primary operand 
			to the left or right by a number of bits determined by the secondary operand.
			The number of bytes affected by the shift is determined by the word data type specifier.
		</p></li>
		<li><p>
			Bits that are shifted to a position outside of the boundary are discarded.
		</p></li>
		<li><p>
			As bits are shifted out of the register boundary to the left, Logical Shift instructions will shift new zero-value bits into the boundary of the register at the lowest significant bit position of the register.
			As bits are shifted out of the register boundary to the right, Logical Shift instructions will shift new zero-value bits into the boundary of the register at the highest significant bit position of the register.
		</p></li>
	</ol>
	<h3>Arithmetic Shift Right</h3>
	<ol>
		<li><p>
			Arithmetic Shift Right performs exactly the same shifting operation as the Logical Shift Right instruction.
		</p></li>
		<li><p>
			Bits that are shifted to a position outside of the boundary are discarded.
		</p></li>
		<li><p>
			As bits are shifted out of the register boundary to the right, the Arithmetic Shift Right instruction will shift new one-value bits into the boundary of the register at the highest significant bit position of the register.
		</p></li>
	</ol>
	<h3>Bit Rotation Instructions</h3>
	<ol>
		<li><p>
			Rotation instructions will perform bit shifting operations in the same manner as the logical shift instructions.
		</p></li>
		<li><p>
			Bits that are shifted to a position outside the boundary are shifted back into the boundary from the opposite side from where they were shifted out of the boundary.
		</p></li>
	</ol>
	<h2>Conversion Instructions</h2>
	<ol>
		<li>
			<table>
				<tr><th>Instruction</th><th>Primary Operand</th><th>Mnemonic</th><th>Secondary Operand</th><th>Writes to:</th></tr>
				<tr><td>Sign Extend:</td><td>Register</td><td>x</td><td>Word Data Type</td><td>Primary Operand</td></tr>
				<tr><td>Zero Extend:</td><td>Register</td><td>z</td><td>Word Data Type</td><td>Primary Operand</td></tr>
				<tr><td>Convert to Large Floating Point:</td><td>Register</td><td>F</td><td>-</td><td>Primary Operand</td></tr>
				<tr><td>Convert to Small Floating Point:</td><td>Register</td><td>f</td><td>-</td><td>Primary Operand</td></tr>
				<tr><td>Convert from Large Floating Point:</td><td>Register</td><td>U</td><td>-</td><td>Primary Operand</td></tr>
				<tr><td>Convert from Small Floating Point:</td><td>Register</td><td>u</td><td>-</td>Primary Operand</tr>
			</table>
		</li>
		<li><p>
			The secondary operand is a second word data type mnemonic like the word data type specifier that gives the byte size that the value in the primary operand will be converted to.
		</p></li>
	</ol>
	<h3>Sign Extend</h3>
	<ol>
		<li><p>
			The Sign Extend instruction will convert a signed binary value of a size given by the word data type specifier to a signed binary value of a size given by the secondary operand.
		</p></li>
		<li><p>
			The Sign Extend instruction shall always preserve the literal numerical value encoded in the binary number so that it is the same before and after the instruction is carried out.
		</p></li>
	</ol>
	<h3>Zero Extend</h3>
	<ol>
		<li><p>
			The Zero Extend instruction will convert an unsigned binary value of a size given by the word data type specifier to an unsigned binary value of a size given by the secondary operand.
		</p></li>
		<li><p>
			The Zero Extend instruction shall always preserve the literal numerical value encoded in the binary number so that it is the same before an after the instruction is carried out.
		</p></li>
	</ol>
	<h3>Convert to Large/Small Floating Point</h3>
	<ol>
		<li><p>
			The data type and binary format of the literal value contained in the Primary Operand will be converted to a Large or Small Floating Point data type.
		</p></li>
		<li><p>
			Behavior is undefined if the data type of the Primary Operand is a Large or Small Floating Point before the instruction is executed.
		</p></li>
	</ol>
	<h3>Convert from Large/Small Floating Point</h3>
	<ol>
		<li><p>
			The literal value represented by the Large or Small floating point format shall be converted to a different data type format determined by the word data type specifier.
		</p></li>
		<li><p>
			Behavior is undefined if the word data type specifier for the instruction is a Large or Small Floating Point.
		</p></li>
		<li><p>
			Behavior is undefined if the data type of the Primary Operand is not a Large or Small Floating Point before the instruction is executed.
		</p></li>
	</ol>
	<h2>Special Instructions</h2>
	<ol>
		<li>
			<table>
				<tr><th>Instruction</th><th>Primary Operand</th><th>Mnemonic</th><th colspan="8"></th></tr>
				<tr><td>No Operation (NOP):</td><td>-</td><td>.</td></tr>
				<tr><td>System Call:</td><td>Register</td><td>y</td><td>Register</td><td>...</td><td>y</td></tr>
			</table>
		</li>
		<li><p>
			The System Call instruction will perform a system call<sup><a href="terms.html#term: system call">?</a></sup> according to the conventions of the host computer system.
			It accepts any number of registers as operands.
			The ordering and contents of the registers must be decided according to the system calls for the target architecture.
		</p></li>
	</ol>
	<h3>No Operation</h3>
	<ol>
		<li><p>
			The execution of this instruction shall not have any effect.
		</p></li>
		<li><p>
			The execution of this instruction shall take one normal interpretation and execution cycle as would be required from the CPU by other BRISC instructions.
		</p></li>
	</ol>
	<h3>System Call</h3>
	<ol>
		<li><p>
			The System Call instruction will perform a system call operation as defined by the target operating system.
		</p></li>
		<li><p>
			The System Call instruction uses a variable number of register operands.
		</p></li>
		<li><p>
			The registers included in the System Call instruction are delimited by the instruction mnemonic.
			<code>y</code> will appear twice, once before the secondary operand, and once after the last operand.
		</p></li>
		<li><p>
			The value contained in the primary operand will be the value used to specify which system call is being performed.
		</p></li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->

	<h1 id="object">Binary Object Format</h1>
	<ol>
		<li><p>
			BRISC programs are stored for execution and reuse using an object format.
			This object format is called "BOF" (Bran Object File).
		</p></li>
		<li><p>
			All components of the BOF format are encoded using ASCII values.
		</p></li>
		<li>
			<p>
				The BOF format has the following components...
			</p>
			<ul>
				<li>Compound Type List</li>
				<li>Surface Table</li>
				<li>Structure Table</li>
				<li>Link List</li>
				<li>Type Declaration List</li>
				<li>Segments</li>
				<li>Symbols</li>
				<li>Sizes</li>
				<li>Numbers</li>
				<li>Binary Data</li>
			</ul>
		</li>
		<li><p>
			A BOF object that begins with the ASCII Bell control (07) can be executed.
		</p></li>
	</ol>
	<h2>BOF Organization</h2>
	<ol>
		<li><p>
			All BOF objects require a Structure Table to be present.
		</p></li>
		<li><p>
			BOF objects can optionally contain a Surface Table, a Link List, and a Compound Type List.
		</p></li>
		<li><p>
			When a BOF object is stored, it is named.
		</p></li>
		<li>
			<p>The ASCII characters accepted in a BOF object filename are...</p>
			<table>
				<tr><td>[a-zA-Z0-9\.\,-_ ]</td></tr>
			</table>
		</li>
		<li>
			<p>The ordering of the sections in a BOF object is as follows...</p>
			<ol>
				<li><i>Required:</i> BOF Tag ('B', 'R', 'A', 'N')</li>
				<li><i>Optional:</i> Executable Specifier (0a)</li>
				<li><i>Optional:</i> Link List</li>
				<li><i>Optional:</i> Surface Table</li>
				<li><i>Required:</i> Structure Table</li>
				<li><i>Required:</i> Segment</li>
				<li><i>Optional:</i> Additional Segments</li>
			</ol>
		</li>
		<li><p>
			All BOF objects begin with the four byte ASCII sequence <code>BRAN</code>, which can be used to identify that the BOF format is present.
		</p></li>
		<li><p>
			All BOF objects require at least one Segment to be included.
		</p></li>
		<li><p>
			All additional Segments shall be appended to the end of the BOF object.
		</p></li>
		<li><p>
			The Link List shall be prefixed with the ASCII Acknowlegement code (06).
		</p></li>
		<li><p>
			The Compound Type List shall be prefixed with the ASCII File Separator code (1c).
		</p></li>
		<li><p>
			The Surface Table shall be prefixed with the ASCII Group Separator code (1d).
		</p></li>
		<li><p>
			The Structure Table shall be prefixed with the ASCII Record Separator code (1e).
		</p></li>
		<li><p>
			The Compound Type List shall be prefixed with the ASCII Unit Separator code (1f).
		</p></li>
		<li><p>
			The first Segment following the Structure Table shall be prefixed with the ASCII End of Medium code (19).
		</p></li>
		<li><p>
			It is not specified whether additional data or segments can be included at the end of the BOF object.
		</p></li>
	</ol>
	<h2 id="Object Symbol">Symbols</h2>
	<ol>
		<li><p>
			Symbols are used to identify individual Segments in a BOF file.
		</p></li>
		<li>
			<p>
				Symbols consist of a series of printable ASCII characters delimited by a "null" character (ASCII 00).
			</p>
			<table>
				<tr><td>[\x20-\x7E]*\x00</td></tr>
			</table>
		</li>
		<li><p>
			Each symbol used in a BOF file must contain a unique sequence of characters.
			No two Symbols used in the same BOF file shall contain identical sequences of characters.
		</p></li>
	</ol>
	<h2>Sizes</h2>
	<ol>
		<li><p>
			Sizes are used to specify the size of an object component.
		</p></li>
		<li>
			<p>
				Sizes are a sixteen-digit hexadecimal number.
			</p>
			<table>
				<tr><td>[0-9a-fA-F]{16,16}</td></tr>
			</table>
		</li>
	</ol>
	<h2 id="Object Number">Numbers</h2>
	<ol>
		<li><p>
			Numbers are used to represent a single binary number.
		</p></li>
		<li>
			<p>
				Numbers consist of a variable-width hexadecimal notation.
			</p>
			<table>
				<tr><td>\x05[0-9a-f][0-9a-f]{1,16}</td></tr>
			</table>
		</li>
		<li><p>
			Numbers are prefixed with the ASCII Enquiry code (05).
		</p></li>
		<li><p>
			The value of the first digit of a Number shall specify a corresponding number of digits in the hexadecimal number.
		</p></li>
		<li><p>
			The number of hexadecimal digits shall always match the number given by the first digit.
		</p></li>
		<li><p>
			Numbers shall always be interpreted as whole, positive (unsigned), binary-encoded numbers.
		</p></li>
		<li><p>
			All binary number encodings implicitly have a counterpart unsigned binary value with identical bit placement.
			All binary number encodings shall be represented by their unsigned binary counterpart.
		</p></li>
	</ol>
	<h2>Binary Data</h2>
	<ol>
		<li><p>
			Binary Data does not have a specific format.
			It consists of a contiguous series of unsigned byte values.
		</p></li>
		<li><p>
			Binary Data shall be signified by the use of a Size as the type declaration for a Symbol entry.
		</p></li>
	</ol>
	<h2>Compound Type List</h2>
	<ol>
		<li><p>
			Any Compound Data Types used in a BOF object must be declared in the Compound Type List.
		</p></li>
		<li><p>
			The Compound Type List consists of a number of compound type declarations.
		</p></li>
		<li><p>
			The Compound Type list is bounded by a pair of ASCII Line Feed codes (0a).
		</p></li>
		<li><p>
			The order of the declarations in the Compound Type List does not matter.
		</p></li>
	</ol>
	<h3>Box</h3>
	<ol>
		<li><p>
			The Box data type will contain a number of data fields.
			These data fields do not need to be the same type.
		</p></li>
		<li><p>
			A Box enforces that its data fields are adjacent in memory in the order that they were declared in the Box data type declaration.
		</p></li>
		<li><p>
			Data fields in a Box can optionally be declared as memory-word aligned.
			This will cause the Box type to allow gaps of unused memory around those fields in order to preserve their alignment.
		</p></li>
		<li>
			<p>
				The syntax for declaring a Box data type is...
			</p>
			<table>
				<tr><td><b>Box</b> &rarr; <i>BoxB</i> <i>Symbol</i> <b>Contents</b> <i>BoxE</i></td></tr>
				<tr><td><i>BoxB</i> &rArr; \[</td></tr>
				<tr><td><i>Symbol</i>&rArr; [\x20-\x7e]\x00</td></tr>
				<tr><td><b>Contents</b> &rarr; <b>Contents</b> <b>Contents</b> | <i>type</i> <i>type</i> <i>padding</i></td></tr>
				<tr><td><i>type</i> &rArr; [wWhHqQbB@]</td></tr>
				<tr><td><i>padding</i> &rArr; \x32</td></tr>
				<tr><td><i>BoxE</i> &rArr; \]</td>
			</table>
		</li>
		<li><p>
			A Box declaration shall be bounded by a closed pair of square brackets.
		</p></li>
		<li><p>
			Box data fields will be declared using word data type names.
		</p></li>
		<li><p>
			A blank space after a field declaration signifies that that field shall be aligned along a memory word boundary.
		</p></li>
	</ol>
	<h3>Index</h3>
	<ol>
		<li><p>
			The Index type shall contain a number of data fields of uniform type.
		</p></li>
		<li><p>
			Indexes shall occupy a contiguous section of memory.
		</p></li>
		<li><p>
			Data fields shall not be memory aligned in an Index type.
		</p></li>
		<li><p>
			The number of fields in an Index data type shall be a static, whole number.
		</p></li>
		<li>
			<p>The syntax for declaring an Index type is...</p>
			<table>
				<tr><td><b>Index</b> &rarr; <i>IndexB</i> <i>Symbol</i> <i>type</i> <i>size</i></td></tr>
				<tr><td><i>IndexB</i> &rArr; \|</td></tr>
				<tr><td><i>Symbol</i> &rArr; [\x20-\x7e]\x00</td></tr>
				<tr><td><i>type</i> &rArr; [wWhHqQbB@] | <i>Delimit</i> <i>Symbol</i></td></tr>
				<tr><td><i>Delimit</i> &rArr; \x00</td></tr>
				<tr><td><i>size</i>[0-9a-f][0-9a-f]{1,16}</td></tr>
			</table>
		</li>
		<li><p>
			The type of the data fields in an Index can be a Box type as well as a word data type.
			If an Index is declared that contains Box-type data fields, the Symbol used when declaring that Box type is written where a word type is expected.
		</p></li>
		<li><p>
			If a compound type Symbol is used instead of a word data, the Symbol is prefixed with another ASCII Null character (00).
		</p></li>
	</ol>
	<h3>Shelf</h3>
	<ol>
		<li><p>
			The Shelf type will be used to access the program stack.
		</p></li>
		<li><p>
			Shelf types shall represent the ordering of data types on the program stack relative to the address of the top of the stack.
		</p></li>
		<li><p>
			Shelf types shall enforce memory-word alignment of data on the program stack.
		</p></li>
		<li>
			<p>The syntax for declaring a Shelf type is...</p>
			<table>
				<tr><td><b>Shelf</b> &rarr; <i>ShelfB</i> <b>Contents</b> <i>separator</i> <i>Symbol</i> <b>Contents</b> <i>ShelfE</i></td></tr>
				<tr><td><i>ShelfB</i> &rArr; \(</td></tr>
				<tr><td><b>Contents</b> &rarr; <b>Contents</b> <b>Contents</b> | <i>type</i></td></tr>
				<tr><td><i>type</i> &rArr; [wWhHqQbB@] | <i>Symbol</i></td></tr>
				<tr><td><i>separator</i> &rArr; ,</td></tr>
				<tr><td><i>Symbol</i> &rArr; [\x20-\x7e]\x00</td></tr>
				<tr><td><i>ShelfE</i> \)</td></tr>
			</table>
		</li>
		<li><p>
			The location of the data fields in a Shelf type shall be relative to the position of the field declaration to the Shelf Symbol declaration.
		</p></li>
		<li><p>
			The data fields declared before the Shelf Symbol shall be located before the top of the program stack.
		</p></li>
		<li><p>
			The leftmost data field declared before the Shelf Symbol shall be located farthest before the address of the top of the program stack.
			The rightmost data field declared before the Shelf Symbol shall be located immediately before the address of the top of the program stack.
			The fields declared between the leftmost and rightmost field before the Shelf Symbol shall be located in the order they were declared between the location of the leftmost field and the rightmost field before the top of the program stack.
		</p></li>
		<li><p>
			The data fields declared after the Shelf Symbol shall be located after the top of the program stack.
		</p></li>
		<li><p>
			The leftmost data field declared immediately after the Shelf Symbol shall be located at the address of the top of the program stack.
		</p></li>
		<li><p>
			Each data field declared after the leftmost data field following the Shelf Symbol shall be located at the next unused memory address following the location of the previous data field.
		</p></li>
	</ol>
	<h2>Link List</h2>
	<ol>
		<li><p>
			The Link List shall contain a series of BOF object names that shall be loaded with the local BOF object.
		</p></li>
		<li><p>
			Each entry in the list shall contain the name of a single BOF object.
		</p></li>
		<li><p>
			An entry can optionally contain the global location of a BOF object within the target operating system's directory structure.
		</p></li>
		<li>
			<p>
				The syntax for specifying a global location of a BOF object is...
			</p>
			<table>
				<tr><td><b>Path</b> &rarr; <b>Dir</b> <i>Name</i></td></tr>
				<tr><td><b>Dir</b> &rarr; <b>Dir</b> <b>Dir</b> | <i>Folder</i> <i>Separator</i></td></tr>
				<tr><td><i>Folder</i> &rArr; <i>Name</i></td></tr>
				<tr><td><i>Separator</i> &rArr; /</td></tr>
				<tr><td><i>Name</i> &rArr; [a-zA-Z0-9\.\,-_ ]</td></tr>
			</table>
		</li>
		<li><p>
			If a location in a target operating system contains a character not allowed in Link List entries, it shall be treated as inaccessible.
			That is to say, only global locations specifiable using allowable Link List entry characters are accessible to the Bran environment.
		</p></li>
	</ol>
	<h2>Tables</h2>
	<ol>
		<li><p>
			Tables are used to declare the Segments that will be included in the loading and linking process for a BOF file.
		</p></li>
		<li><p>
			The Surface and Structure Tables contains entries that declare Segments present in the BOF file.
		</p></li>
		<li><p>
			The Surface Table contains Symbol entries that can be used internally within the local BOF object and also externally when the local BOF object is being linked to an external BOF object.
		</p></li>
		<li><p>
			If a BOF object is executable, the instruction pointer register (<code>//i</code>) will be set to the beginning of the contents of the Segment associated with the first Symbol entry in the Surface Table.
		</p></li>
		<li><p>
			The Structure Table contains Symbol entries that can only be used internally within the local BOF object.
		</p></li>
		<li><p>
			All Symbol entries across both tables must be unique.
		</p></li>
		<li><p>
			A Symbol entry shall always have a corresponding Segment included in the local BOF object unless that Segment is flagged as uninitialized (see the list of flags below).
		</p></li>
	</ol>
	<h3>Symbol Entries</h3>
	<ol>
		<li><p>
			Symbol entries for the Surface and Structure tables contain a Symbol, followed by a flag, followed by a type descriptor.
		</p></li>
		<li>
			<p>
				Flags are single ASCII characters following the Symbol delimiter.
				Flags signify the availability of a Segment for reading, writing, and interpretation during execution of a BRISC program.
				The flags for Symbol entries are...
			</p>
			<dl>
				<dt>e</dt>
				<dd>
					Signifies an <i>external</i> symbol that will be found in one of the objects listed in the Link Table.
					No type descriptors shall follow this flag.
				</dd>
				<dt>r</dt>
				<dd>
					Indicates that the Segment associated with this Symbol is <i>readable</i>, but not writeable
				</dd>
				<dt>w</dt>
				<dd>
					Indicates that the Segment associated with this Symbol is <i>writeable</i> and readable.
				</dd>
				<dt>u</dt>
				<dd>
					Indicates that the Segment associated with this Symbol is writeable and readable, but contains no data.
					That is to say, the Segment is <i>uninitialized</i> or empty.
				</dd>
				<dt>B</dt>
				<dd>
					Indicates that the Segment associated with the Symbol is readable and executable and contains BRISC encoded instructions.
				</dd>
				<dt>n</dt>
				<dd>
					Indicates that the Segment associated with the Symbol is readable and executable and contains encoded instructions using the format of the target architecture, or the <i>native</i> instruction format.
				</dd>
				<dt>f</dt>
				<dd>
					Indicates that the Segment associated with the Symbol is readable and executable and contains encoded instructions for a non-BRISC, non-native, <i>foreign</i> architecture.
					The means for determining the format of <b>f</b> Segments is not specified.
				</dd>
			</dl>
		</li>
		<li><p>
			A type descriptor is one of three things, a BRISC word data type name, a Compound Data Type Symbol, or a Size specifier.
		</p></li>
	</ol>
	<h2>Segments</h2>
	<ol>
		<li><p>
			Segments are used to contain the text and data required to load and execute a BRISC program.
		</p></li>
		<li><p>
			The size of a Segment shall be determined by the size in bytes of the type associated with that Segment in its corresponding Symbol entry.
			The size of a Segment shall exactly match the size in bytes of the type associated with that Segment in its corresponding Symbol entry.
		</p></li>
		<li>
			<p>
				Data in a Segment shall be formatted according to the type given for that Segment in its corresponding Symbol entry.
			</p>
			<p>
				In a Segment given a Word Data Type, data shall be formatted as a big-endian binary number.
				The first byte of the Segment corresponds to the most significant byte in the data type.
				The last byte of the Segment corresponds to the least significant byte in the data type.
			</p>
			<p>
				In a Segment given a Compound Data Type, data shall be formatted as a series of big-endian numbers.
				Each number shall correspond to a single data field of the Compound Data Type.
				The numbers shall be ordered according to the order that the data fields were declared in the Compound Data Type declaration.
			</p>
			<p>
				In a Segment given a Size as a data type, the data shall be either an unspecified format, or a series of encoded BRISC instructions.
				A Segment given a Size type that contains encoded BRISC instructions must always be given an <b><i>f</i></b> flag.
			</p>
			<p>
				A Segment that contains BRISC instructions must always be given a Size type.
			</p>
		</li>
		<li><p>
			Segments shall always be prefixed by the Symbol associated with that Segment in its corresponding Symbol entry.
		</p></li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1 id="execution">Execution</h1>
	<ol>
		<li><p>
			There are three logical stages required to prepare a BOF object for execution, Linking, Translation, and Loading.
			These three stages shall be automated by one or more programs.
			These programs are referred to as "Broccoli". (This is another play on the programming language name as the food broccoli, like bran, is said to be rich in fiber.)
		</p></li>
		<li><p>
			Broccoli shall be callable or invokable by a user of the target operating system.
			The method with which Broccoli is invoked is not specified, only its availability is required.
		</p></li>
		<li><p>
			The user of the target operating system must be provided the means to supply Broccoli with a BOF object to execute.
		</p></li>
		<li><p>
			Broccoli shall verify that the format of all BOF objects it encounters during the execution process is correct.
		</p></li>
		<li><p>
			If the format of a BOF object file is incorrect, Broccoli shall not execute any BOF object and exit.
		</p></li>
		<li><p>
			It is unspecified if, upon detecting a malformatted BOF object, Broccoli will communicate any information to the user before it exits.
		</p></li>
		<li><p>
			A BOF object that is marked executable is required for Broccoli to execute a program.
		</p></li>
		<li><p>
			Broccoli shall support the instruction encoding format used by its host system.
		</p></li>
		<li><p>
			Broccoli shall be able to load and execute a BOF object containing any combination of both <i>B</i> and <i>n</i> formatted segments.
		</p></li>
		<li><p>
			Broccoli is not required to be able to manipulate any the instruction format of <i>f</i> segments.
		</p></li>
	</ol>
	<h2>Linking</h2>
	<ol>
		<li><p>
			The Linking stage shall be responsible for gathering all Segments required by a single program in order for its execution.
		</p></li>
		<li><p>
			The Segments required by a program are not required to be contained within a single BOF object.
			A single BRISC program may be contained across multiple BOF objects.
		</p></li>
		<li><p>
			The BOF objects required for executing a program are determinedd by the Link List entries in the objects loaded by Broccoli.
		</p></li>
		<li><p>
			An object that was loaded from a Link List can also require further objects to be loaded by Broccoli in its own Link List.
		</p></li>
		<li><p>
			The Segments required for executing a program are determined by the Surface and Structure tables in the BOF objects loaded by Broccoli.
		</p></li>
		<li><p>
			If a BOF object attempts to use a Segment that is not declared in the table of any loaded object, Broccoli shall exit.
		</p></li>
		<li><p>
			Broccoli shall disregard Segments that are not used by the program.
		</p></li>
		<li><p>
			A Segment shall be determined to be unused if it is not used in any BRISC instruction segments.
		</p></li>
	</ol>
	<h2>Translation</h2>
	<ol>
		<li><p>
			The Translation stage shall be responsible for converting the Linked Segments into a program image that is interpretable by the target architecture.
		</p></li>
		<li><p>
			The exact organization of a program image is dependent on the program image format used by the target operating system.
		</p></li>
		<li><p>
			Broccoli will take all Segments and organize them into sections of memory based on whether the Segments are read-only, writeable and readable, or read-only and executable.
		</p></li>
		<li><p>
			If the target operating system does not support read-only or executable-only memory, the organization of those Segments is not specified.
		</p></li>
		<li><p>
			Any Segments that contain BRISC instructions are translated by Broccoli into instructions that are interpretable by the target architecture.
		</p></li>
		<li><p>
			Broccoli will resolve the locations included in any loading and storing instructions by the BRISC program so that the resulting translated program will still perform the memory accesses in the manner specified by the BRISC instructions.
		</p></li>
		<li><p>
			The translated program shall exhibit the same behavior as the BRISC program if it were to be interpreted directly.
		</p></li>
		<li><p>
			If the number of registers used in a BRISC program does not match the number of registers available in the target architecture, Broccoli will resolve which values are held in the registers at all given points during execution so that the behavior of the translated program will exhibit the same behavior as the BRISC program if it were to be interpreted directly.
		</p></li>
		<li><p>
			The format of any data used by the BRISC program shall be transformed to a format that is interpretable by the target architecture such that the literal information stored in the data is preserved across formats.
			This transformation is not required if the format of the data as it was stored in a BOF object is immediately interpretable by the target architecture.
		</p></li>
	</ol>
	<h2>Loading</h2>
	<ol>
		<li><p>
			Broccoli shall claim a portion of memory from the target operating system where it will place the translated BRISC program and data.
		</p></li>
		<li><p>
			The memory claimed by Broccoli for storing the translated BRISC program shall have one or more sections with read, write, or executable permissions, enabling a program image to be placed within it.
		</p></li>
		<li><p>
			The memory claimed by Broccoli must have a section with executable permission large enough for the translated instruction Segments of the BRISC program to be stored in it.
		</p></li>
		<li><p>
			The Segments with read, write, and executable flags corresponding to a section of memory shall be placed in that section of memory.
		</p></li>
		<li><p>
			If the target operating system does not support read, write, or executable permissions in memory, the placement of Segments in memory is undefined.
		</p></li>
		<li><p>
			When all Segments used by the BRISC program have been placed in the claimed memory, Broccoli shall initialize a new process using the conventions of the target operating system.
		</p></li>
		<li><p>
			The new process initialized by Broccoli shall begin execution of the translated BRISC program at the location corresponding to the first entry in the Surface Table located in the BOF object initially submitted to Broccoli for execution.
		</p></li>
		<li><p>
			It is not specified if Broccoli will exit after successfully executing a program.
		</p></li>
	</ol>
	<h2>Verification</h2>
	<ol>
		<li><p>
			It is unspecified if Broccoli will verify the format and intgrity of BOF objects and BRISC code.
		</p></li>
		<li><p>
			If Broccoli encounters a state where it cannot complete the execution of a BOF file, it shall communicate a failure and exit.
		</p></li>
		<li><p>
			If Broccoli does inspect BOF objects and BRISC code for correctness and it encounters some error, the format and amount of information Broccoli shall provide about the error is not specified.
		</p></li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1>The fiber Programming Language</h1>
	<ol>
		<li><p>
			fiber is a computer programming language designed for general purpose application.
		</p></li>
		<li><p>
			fiber provides the programmer with the basic utilities for organizing data into compound structures, performing arithmetic on numbers, and creating functions and variables.
		</p></li>
		<li><p>
			fiber also provides the programmer with advanced capabilities for defining custom data types, creating modules, metaprogramming, higher order functions, type checking, and proof verification of program behavior.
		</p></li>
	</ol>
	<h1>Environment</h1>
	<ol>
		<li><p>
			The fiber language environment consists of a program or series of programs that will interpret fiber syntax stored in a number of source files and execute the program those source files describe.
		</p></li>
		<li><p>
			The interpretation of a fiber program can include any number of translations to different interpretable formats representing an identical program.
		</p></li>
		<li><p>
			Translation of a source file can take place at any point.
			Translated source files are referred to as "cached" source files.
		</p></li>
	</ol>
	<h2>Program Organization</h2>
	<ol>
		<li><p>
			A single fiber program consists of a series of source files, some of which may be cached.
		</p></li>
		<li><p>
			Source files are organized using a system of <u>modules</u> defined with fiber syntax.
			The syntax for describing modules is specified in <a href="#fiber module">(<i>Modules</i>)</a>.
		</p></li>
		<li><p>
			A module definition must be entirely contained within a single source file.
		</p></li>
		<li><p>
			A source file may contain any number of complete modules.
		</p></li>
		<li><p>
			A module may specify the inclusion of other modules within itself.
			A module may also specify the inclusion of source files that do not contain modules or cached source files.
		</p></li>
		<li><p>
			A module contains a number of named program components.
			Each component may either be <u>declared</u>, or <u>defined</u>.
		</p></li>
		<li><p>
			The definition of a declared component is required to be included before that component is used in a program.
		</p></li>
		<li><p>
			A declared program component consists of an interface described in fiber syntax with the behavior of that component described in an external source file specified by the module containing the definition.
		</p></li>
		<li><p>
			A defined program component consists of an interface <i>and</i> behavior description contained within a single module containing both descriptions.
		</p></li>
		<li><p>
			All program components described in a module are part of that module's <u>namespace</u> such that program component names are only required to be unique from other names within the same module.
		</p></li>
		<li><p>
			In order for program components to be accessible externally from their module, they must be specified as externally accessible.
		</p></li>
		<li><p>
			If a module is included that contains an externally accessible name identical to a name in an including module, the containing module must be specified when using either name.
		</p></li>
	</ol>
	<h2>Program Execution</h2>
	<ol>
		<li><p>
			The execution of a fiber program is initiated by calling a function contained in a fiber program.
		</p></li>
		<li><p>
			The method with which a function is called is dependent on the target system.
		</p></li>
		<li><p>
			The function to be called in order to execute a certain program may be decided at any time.
		</p></li>
		<li><p>
			There are two processes responsible for the execution of a fiber program: the <u>staging process</u> and the <u>interpretation process</u>.
		</p></li>
		<li><p>
			The staging process shall begin directly after a function is called.
		</p></li>
		<li><p>
			The staging process shall allocate computing resources sufficient for executing that function.
			This may include additional source files.
		</p></li>
		<li><p>
			The staging process shall also set any program objects to their initial values if they any are provided.
		</p></li>
		<li><p>
			The staging process shall finish when the resources and objects necessary for the execution of the function have been successfully allocated.
		</p></li>
		<li><p>
			The interpretation process will begin after the staging process is complete. 
		</p></li>
		<li><p>
			The interpretation process shall carry out the specified behavior of the program.
		</p></li>
		<li><p>
			The method or methods of interpretation with which a program is executed is not specified.
		</p></li>
		<li><p>
			The interpretation process shall finish when the end of the function is reached.
		</p></li>
		<li><p>
			The function called to begin execution is not required to return.
		</p></li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1>Syntax Components</h1>
	<ol>
		<li><p>
			The syntax of fiber is comprised of expressions and declarations which can be decomposed into two classes of tokens: <u>Symbols</u> and <u>Operators</u>.
		</p></li>
		<li>
			<p>
				All tokens are delimited by any blank or non-printable characters. 
				This includes any non-printable or blank characters specified by the Unicode standard.
			</p>
			<table><tr><td><i>Delimiter</i> &rArr; [\x00- \x7F]*</td></tr></table>
		</li>
		<li><p>
			Multiple delimiting characters occurring in an contiguous series will be treated as a single literal delimiter.
		</p></li>
		<li><p>
			A symbol is a contiguous series of alphanumeric characters.
			This includes any language script characters specified by the Unicode standard.
			</p>
			<table><tr><td><i>Symbol</i> &rArr; [0-9A-Fa-f]*</td></tr></table>
		</li>
		<li><p>
			Symbols shall also be delimited by operator tokens and non-alphanumeric characters.
		</p></li>
		<li>
			<p>
				An operator is a contiguous series of non-alphanumeric characters.
				This includes any non-lingual, symbolic characters as specified by the Unicode standard.
			</p>
			<table><tr><td><i>Oprator</i> &rArr; [!-\/:-@\[-`\{-~]*</td></tr></table>
		</li>
		<li><p>
			Operators shall also be delimited by symbol tokens and other alphanumeric characters.
		</p></li>
	</ol>
	<h2>Comments</h2>
	<ol>
		<li><p>
			Comments are bounded by the comment operator, <code>``</code>.
		</p></li>
		<li><p>
			Any character will be accepted between a pair of comment operators except for two backquotes in succession, which is the comment operator.
		</p></li>
		<li><p>
			The text between a pair of comment operators shall be discarded before interpretation of the fiber syntax.
		</p></li>
	</ol>
	<h1>Declarations</h1>
	<ol>
		<li><p>
			Declarations are expression statements that instantiate data objects and other program constructs.
		</p></li>
		<li><p>
			Declarations do not produce a data object when evaluated.
		</p></li>
	</ol>
	<h2>Constant Values</h2>
	<h3>Numbers</h3>
	<ol>
		<li><p>
			A Symbol shall be interpreted as a decimal value if it contains only the decimal digits zero through nine.
			</p>
			<table><tr><td><i>Decimal</i> &rArr; [0-9]*</td></tr></table>
		</li>
		<li><p>
			A Symbol shall be interpreted as a hexadecimal value if it contains only the hexadecimal digits zero through nine, the uppercase letters <b>A</b> through <b>F</b>, and is prefixed by the sequence <code>0x</code>.
			</p>
			<table><tr><td><i>Hex</i> &rArr; 0x[0-9A-F]*</td></tr></table>
		</li>
	</ol>
	<h4>Number Operators</h4>
	<ol>
		<li><p>
			The prefix minus operator <code>-</code> shall accept a decimal or hexadecimal constant declaration as an operand and will negate the value represented by that constant.
		</p></li>
		<li><p>
			The binary radix operator <code>.</code> shall accept decimal constant declarations for both operands and shall produce a rational value using the left operand as the integer component of the resulting value and the right operand as the fractional component.
		</p></li>
		<li><p>
			Neither the minus operator or the radix operator shall be associative.
		</p></li>
		<li><p>
			It is possible for the minus operator to prefix the left operand of a radix operator.
			The combination of the minus prefix and the radix shall result in a negative rational value.
		</p></li>
		<li><p>
			Number constant operators shall not accept identifiers or non-number declarations.
		</p></li>
	</ol>
	<h3>Character Literals</h3>
	<ol>
		<li><p>
			A character literal is the numerical value associated with a code point in a character encoding scheme.
			fiber supports character literal values for ASCII and Unicode encoding.
		</p></li>
		<li><p>
			An ASCII character literal value shall be declared by writing a printable ASCII character surrounded by double quotations. <code>"A"</code>
		</p></li>
		<li><p>
			The double quotation character and the backward slash character shall be prefixed by a backward slash character before they are surrounded by double quotations. <code>"\\"</code> <code>"\""</code>
		</p></li>
		<li id="character literals non-printable"><p>
			Non-printable ASCII character literals shall be represented by a two-digit hexadecimal number declaration specifying the numerical value of the character literal.
			The number shall be prefixed with a forward slash and then surrounded by double quotations. <code>"\20"</code>
		</p></li>
		<li><p>
			A Unicode character literal shall be declared by writing a Unicode character surrounded by double quotations in the same manner as an ASCII character.
			This method shall require that the source file support UTF-8 encoding.
		</p></li>
		<li><p>
			A Unicode character literal may be alternatively declared using a hexadecimal number declaration specifying the numerical value of the Unicode code point being declared.
			The number shall be prefixed with the sequence <code>\U</code>, delimited by a period dot, and then surrounded by double quotations. <code>"\U2000."</code>
			This method does not require UTF-8 encoding.
		</p></li>
		<li><p>
			The symbol and operator tokenization rules are disregarded concerning the syntax between quotations.
			This is necessary to properly express character literal values.
		</p></li>
	</ol>
	<h3>String Data</h3>
	<ol>
		<li><p>
			String data consists of a contiguous series of character values.
			Character values may be ASCII or Unicode values.
		</p></li>
		<li><p>
			String data is declared using the same syntax as a character literal, but including more than one character inside the pair of quotations.
		</p></li>
		<li><p>
			Each character in a string shall use one of the declaration methods provided above for character literal values.
		</p></li>
		<li><p>
			An ASCII string shall contain only ASCII character encodings.
		</p></li>
		<li><p>
			A Unicode string shall contain at least one Unicode character that is not included in the ASCII encoding scheme.
		</p></li>
		<li><p>
			Control characters and other non-printable characters shall be declared in string data exclusively with the format specified in <a href="#character literals non-printable">(<i>Character Literals, 4</i>)</a>.
		</p></li>
		<li><p>
			Control character values occurring normally in the source file inside a string data declaration shall be discarded.
		</p></li>
	</ol>
	<h4>Byte Strings</h4>
	<ol>
		<li><p>
			Byte strings are a special instance of string data that contain no format or other encoding.
		</p></li>
		<li><p>
			A byte string shall be signified by prefixing the opening quotation with the number sign <code>#"</code>.
		</p></li>
		<li><p>
			A byte string shall be declared by writing a series of two-digit hexadecimal numerical constants.
		</p></li>
		<li><p>
			Blank space is allowed, but not required. This declaration <code>#"01 FF"</code> is identical to <code>#"01FF"</code>.
		</p></li>
	</ol>
	<h2>Identifiers</h2>
	<ol>
		<li><p>
			An identifier is used to locate and reuse a data object.
		</p></li>
		<li><p>
			An identifier will be associated with only one data object at any time.
		</p></li>
		<li><p>
			An identifier may be declared with a data type annotation which will coerce the type of the data object the identifier is declared with.
		</p></li>
		<li><p>
			Identifers are declared using the binary assignment operator, <code>=</code>.
		</p></li>
		<li>
			<p>The syntax for declaring an identifier is as follows...</p>
			<table>
				<tr><td><b>Identifier</b> &rarr; <b>Id</b> <i>Assign</i> <b>Decls</b></td></tr>
				<tr><td><i>Assign</i> &rArr; =</td></tr>
				<tr><td><b>Id</b> &rarr; <br>
					| <b>Name</b><br>
					| <i>Multiplex</i> <b>Names</b></td></tr>
				<tr><td><i>Multiplex</i> &rArr; \\</td></tr>
				<tr><td><b>Names</b> &rarr;<br>
				 	| <b>Name</b><br>
					| <b>Name</b> <b>Names</b></td></tr>
				<tr><td><b>Name</b><br>
					| Symbol<br> 
					| Symbol <i>Annotate</i> <b>Type</b></td></tr>
				<tr><td><i>Annotate</i> &rArr; \|</td></tr>
				<tr><td><b>Decls</b> &rarr; <br>
					| <b>Declaration</b><br>
					| <i>Multiplex</i> <b>Declarations</b></td></tr>
				<tr><td><b>Declarations</b> &rarr; <br>
					| <b>Declaration</b><br>
					| <b>Declaration</b> <b>Declarations</b></td></tr>
			</table>
		</li>
		<li><p>
			It is possible to declare multiple identifiers within the same statement using the "multiplex" prefix operator, <code>\</code>.
		</p></li>
		<li><p>
			When the multiplex operator is used to the left of the assignment operator, any number of identifiers will be accepted.
		</p></li>
		<li><p>
			When the multiplex operator is used to the right of the assignment operator, a number of declaration statements equivalent to the number of identifiers declared on the left side shall be expected.
		</p></li>
		<li><p>
			When the left side of the assignment statement is multiplexed, but not the right, the declarative statement on the right will be re-evaluated to produce instantiate a data object for each identifier.
		</p></li>
		<li><p>
			The right side of an assignment statement shall not be multiplexed if the left side of the expression is not also multiplexed.
		</p></li>
		<li><p>
			If both sides of the assignment declaration statement are multiplexed, the identifiers are associated with data objects in corresponding order of their declaration from left to right.
		</p></li>
		<li>
			<p>Some examples of identifier declarations are...</p>
			<code>var1 = 1</code>
			<p>An identifier is assigned a numerical constant.</p>
			<code>\ var2 var3 = "the same string"</code>
			<p>Two variables, <i>var2</i> and <i>var3</i>, are associated with two identical string data objects.</p>
			<code>\ var4 var5 = \ 7 "seven"</code>
			<p><i>var4</i> is assigned a numerical constant and <i>var5</i> is assigned a string data object.</p>
			<code>var1|Int = 10</code>
			<p>An identifier declaration that coerces the type of the numerical constant declaration to a signed integer data type.</p>
		</li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1>Type System</h1>
	<ol>
		<li><p>
			Types are used in fiber to constrain program state to a set of reasonable states.
		</p></li>
	</ol>
	<h2>Primitive Data Types</h2>
	<ol>
		<li><p>
			Primitive data types are provided with the base language by default.
		</p></li>
		<li>
			<p>The primitive data types are...</p>
			<table>
				<tr><th>Type Name</th><th>Size</th><th>Interface Description</th></tr>
				<tr><td>Byte</td><td>1B</td><td>Unsigned binary number</td></tr>
				<tr><td>Nat16</td><td>2B</td><td>...</td></tr>
				<tr><td>Nat</td><td>4B</td><td>...</td></tr>
				<tr><td>Nat64</td><td>8B</td><td>...</td></tr>
				<tr><td>Char</td><td>1B</td><td>Signed binary number</td></tr>
				<tr><td>Int16</td><td>2B</td><td>...</td></tr>
				<tr><td>Int</td><td>4B</td><td>...</td></tr>
				<tr><td>Int64</td><td>8B</td><td>...</td></tr>
				<tr><td>Uncd</td><td>4B</td><td>Unsigned binary number (Unicode values)</td></tr>
				<tr><td>Float</td><td>4B</td><td>IEEE-754 binary floating point</td></tr>
				<tr><td>Real</td><td>8B</td><td>IEEE-754 binary floating point</td></tr>
				<tr><td>Mem</td><td>8B</td><td>Memory address</td></tr>
				<tr><td>True</td><td>1B</td><td>Boolean value</td></tr>
				<tr><td>False</td><td>1B</td><td>Boolean value</td></tr>
			</table>
		</li>
		<li>
			<p>
				The primitive data types are organized in a hierarchy with a number of supertypes.
				The type hierarchy structure is...
			</p>
			<ul>
				<li>Number
					<ul>
						<li>Nat, Nat16, Nat64</li>
						<li>Int, Int16, Int64</li>
						<li>Float</li>
						<li>Real</li>
						<li>Mem</li>
						<li>Byte, Char, Uncd</li>
					</ul>
				</li>
				<li>Bool
					<ul>
						<li>True</li>
						<li>False</li>
					</ul>
				</li>
				<li>Graph
					<ul>
						<li>Char</li>
						<li>Byte</li>
						<li>Uncd</li>
					</ul>
				</li>
				<li>Bin</li>
				<li>Any
					<ul>
						<li>Number</li>
						<li>Bool</li>
						<li>Graph</li>
						<li>Bin</li>
						<li>Any</li>
					</ul>
				</li>
			</ul>
		</li>
	</ol>
	<h2>Data Type Declarations</h2>
	<ol>
		<li><p>
			It is possible to define custom data types.
		</p></li>
		<li><p>
			Custom data type declarations are prefixed with the type definition operator, <code>(></code>, and delimited by a closed parenthese, <code>)</code>.
		</p></li>
		<li><p>
			There are several kinds of data type declarations:
			</p>
			<ul>
				<li>Singular Types</li>
				<li>Constrained Types</li>
				<li>Polymorphic Types</li>
				<li>Compound Types</li>
			</ul>
		</li>
	</ol>
	<h3>Singular Types</h3>
	<ol>
		<li><p>
			Singular types are data types that define the interface to a single data object.
		</p></li>
		<li><p>
			Singular types are used to organize other types into a hierarchical relationship network.
		</p></li>
		<li><p>
			Singular types also provide the means to alias an existing type.
		</p></li>
		<li><p>
			A singular type definition consists of a number of type names listed in any order.
			These types are considered subtypes of the type being defined.
		</p></li>
		<li><p>
			A number of existing supertypes may be declared using a semicolon operator.
			The type names written before the semicolon are declared as supertypes of the type being defined.
			The type names written after the semicolon are declared as subtypes of the type being defined.
		</p></li>
		<li><p>
			A singular type may also specify an expression that a data object must be included in to be of that type.
		</p></li>
		<li>
			<p>Some example singular types are...</p>
			<code>(>a)</code>
			<p>An alias of a type <i>a</i>.</p>
			<code>(>x y z)</code>
			<p>A supertype of the types <i>x</i>, <i>y</i>, and <i>z</i></p>
			<code>(>h i ; j k)</code>
			<p>A supertype of <i>j</i> and <i>k</i> and a subtype of <i>h</i> and <i>i</i></p>
		</li>
	</ol>
	<h3>Constrained Types</h3>
	<ol>
		<li><p>
			Constrained types are data types that define the number of times a data object may be "used" and how the interface to a given data object may change when it is used.
		</p></li>
		<li><p>
			A type listed in the definition may be prefixed with a linear operator, <code>.</code> which declares that the type being defined must be used exactly once with the interface of the type that was listed.
		</p></li>
		<li><p>
			A type listed in the definition may be prefixed with an affine operator, <code>,</code> which declares that the type being defined may be used at least once with the interface of the type that was listed.
		</p></li>
		<li><p>
			A decimal number constant may be provided after a prefixed type name. The number specifies the number of uses that are required in the case of a linear operator prefixe, or the maximum uses allows in the case of an affine operator prefix.
		</p></li>
		<li><p>
			An elipses may be provided after a prefixed type name. The elipses specifies an unknown number of required or maximum uses.
		</p></li>
		<li><p>
			A constrained type may declare that the interface of a data object will change after a certain number of uses. The binary migration operator, <code>&gt;</code> is used to declare an interface change.
		</p></li>
		<li><p>
			The migration operator will accept a constrained type declaration for each operand.
		</p></li>
		<li><p>
			The left operand declares the initial constrained type to be used.
			The right operand declares the constrained type used after the use requirements of the initial type have been met.
		</p></li>
	</ol>
	<h2>Bins</h2>
	<ol>
		<li><p>
			The Bin is used to declare the composition and interface of a compound data type.
		</p></li>
		<li><p>
			The Bin declaration is capable of 
		</p></li>
	</ol>

	<h1>Scope and Duration of Data Objects</h1>
	<ol>
		<li><p>
			All identifiers within a given region of scope will share the same logical name space.
			An identifier shall not be used more than once to identify multiple data objects.
		</p></li>
		<li><p>
			Regions of scope will be implicitly created with function definitions and module declarations.
			Identifiers declared within a function definition or module declaration shall reside within that region of scope.
		</p></li>
		<li><p>
			Regions of scope may be nested. One region may reside within another region.
			Some places this nesting can occur is when a function is defined within a module declaration, or when a module includes an external module.
		</p></li>
		<li><p>
			If an identifier is declared in a region of scope and again in a nested region, the identifier declared in the nested region will "shadow" the identifier declared in the outer region.
			This means that within the nested region, the local declaration of that identifier will always be used.
		</p></li>
	</ol>
<!----------------------------------------------------------------------------->







<!----------------------------------------------------------------------------->
	<h1>Copyright Notice</h1>
	<ol>
		<li><p>
			"Document" refers to this HTML formatted text document.
		</p></li>
		<li><p>
			All rights to this document are reserved by the fiber Group.
		</p></li>
		<li><p>
			Permission to distribute, copy, display, transmit, and otherwise use this document is granted provided that each use includes and preserves the entire document.
		</p></li>
		<li><p>
			Modified copies of this document are expressly not permitted. This includes the modification of HTML tags, hyperlinks, or any other part of this document.
		</p></li>
		<li><p>
			Derivative works and partial copies of this document are expressly not permitted.
		</p></li>
		<li><p>
			Distribution and displayment of this document for the purpose of commercial advantage or financial gain is expressly not permitted.
		</p></li>
	</ol>
	<h2>Disclaimer</h2>
	<ol>
		<li><p>
			By owning a copy of this document, permitted or otherwise, you (the party owning a copy of this document) agree that any and all use of your copy of this document is done at your own exclusive risk.
		</p></li>
	</ol>
</body>

<footer>
	<h1>The fiber Group</h1>
	<ul>
		<h2>Central Author</h2>
		<li>
			<p>Robin</p>
			<p><a href="mailto:yosngne@gmail.com">contact</a></p>

		</li>
		<h2>Official Members</h2>
		<h2>Additional Contributors</h2>
		<li><p>
			qonfluent
		</p></li>
	</ul>
</footer>
